# c语言教程
## 环境搭建
    gcc -v
    g++ -v
    make -v
    gdb -v
    IDE QT http://download.qt.io/archive/qt/
    配置windows unix以达到都可以运行

## include头文件包含
    include是要告诉编译器，包含一个头文件，
    在Ｃ语言当中，任何库函数调用都需要提前包含头文件
    
    <头文件>,代表让c语言编译器去系统目录下寻找相关的头文件.
        在linux下会到/usr/include/目录下找
    “头文件”,代表让c语言编译器去用户当前目录下寻找相关头文件
    
    如果是使用了一个c语言库函数需要的头文件,那么一定是＃include <>   
    如果使用了一个自定义的.h文件,那么一定是#include “”
    如果你把你自定义的.h文件也放到系统目录的/usr/include目录下那么可以使用 <>

## main函数
    main函数是Ｃ语言中的主函数,一个Ｃ语言的程序必须有一个主函数，也只能有一个主函数

## 注释
    //代表注释，就是一个文字说明，没有实质的意义,单行注释	是c++语言的注释方法
    /**/,对行注释,对行注释是标准Ｃ语言注释方法

## {}括号，程序题和代码块
    c语言所有函数的代码都是{}里面包着的

## 声明
    int a
    声明一个变量名字叫a, 对于c语言，变量的名称是可以自定义

## c语言自定义名字的要求
    可以使用大小写字母，下划线，数字，但第一个字母必须是字母或者下划线，
    字母区分大小写
    不能用c语言的关键字作为变量名称
    每一行，必须是分号结尾

## printf 函数
    printf是向标准输出设备输出字符串的
    如果要输出一个字符串：例如:printf(“hello world” );
    如果要输出一个整数,例如: printf(“%d”, 整数)
    Printf(“\n”); 会输出一个回车换行符

## return 语句
    一个函数遇到return 语句就终止了,　return是c语言的关键字

## System系统调用
    system库函数的功能是执行操作系统的命令或者运行指定的程序
    system库函数的调用需要include <stdlib.h> 
        例子
            #include <stdio.h>
            #include <stdlib.h>
            int main(){
                printf("hello world\n");
                system("cat a.c");
                return 0;
            }
    system返回值在windows和unix下的不同
    
    POSIX标准
        b.c:
            #include <stdio.h>
            int main(){
                printf("hello world\n");
                return 100; //主函数return 0一般代表成功的意思,-1代表失败的意思
            }
        a.c:
            #include <stdio.h>
            #include <stdlib.h>
            int main(){
                printf("hello world\n");
                int i = system("cat a.c");
                int b = system("./b");
                printf("%d\n", i);
                printf("%d\n", b); //windows是100 linux是25600
                printf("%x\n", b); //windows是64 linux是6400
                printf("i = %x\n", b / 0x100); //64
                printf("i = %d\n", b / 0x100); //在linux修改以下这个就得到和windows一样的
                //所有的操作系统就windows是最特殊的
                //所以linux写一套代码很多代码都是通用的
                //为什么不一样呢?POSIX标准
                return 0;
            }
        是c语言的代码一种标准和规范
        如果不符合POSIX，代码的运行结果是不一样的
        windows支持的很差
        所以我们在使用库和函数的时候要使用p开头的,符合POSIX标准
        比如在多线程的时候我们最好使用pthread_create



## C语言编译过程,gcc参数简介
    gcc -o a a.c
        在windows编译后是a.exe
        在linux编译后是a，linux是文件名,带不带扩展无所谓的
        生成后的名字自定义的,linux如果不起名字,就是a.out
    
    c语言编译过程
        .c文件－＞预编译－＞编译－＞链接－＞可执行程序
        还有c的库加上去
    
    -E预编译	
        gcc -Ｅ -o a1.c a.c
        预编译a.c文件,生成的目标文件名为a.e
        预编译是将include包含的头文件内容替换到c文件中,同时将代码中没有的注释部分删除
        例如 #include <stdio.h>是将/usr/include/stdio.h文件内容替换到c的文件的中
    
    -S汇编
        gcc -S -o a.s a1.c
        -S就是将c语言转化为汇编语言
    
    -c编译(小写的c)
        gcc -c -o a.o a.s
        将代码编译为二进制的机器指令,但是不能执行
        
    连接(小写的o)
        gcc -o c c.o
        比如printf这个函数是c语言第三方库函数，linux叫.so windows叫.dll
        连接就是将这个函数的二进制连接到我们的程序中一起,然后才能运行
        也就是将库打包到我们的程序中
        gcc没有任何参数,代表就是链接
    
    可以看出java不是这个过程,java编译后不是可执行文件,是一个字节吗文件
    所以java是解释性语言
    
    gcc这个软件命令是很多的命令可以有很多的参数，以上是常用的
        gcc --help
        man gcc

## 操作系统结构
    计算机内存分用户区和内核区
    用户区:普通用户运行在用户区
    内核区:操作系统运行在内核区域
    32位操作系统,最大内存为4G，操作系统占用1G，剩下3G给用户程序
    32为操作系统即使你的硬件内存是8G但是它的最大内存是4G,只能使用4G，所以浪费
    64位操作系统,可能根硬件有关系不一定是2的64次方，但是最大内存肯定是大于4G的
    
    用户模式
        应用程序都是运行在用户区域
    内核模式
        操作系统的内核,设备驱动程序,这些都在内核模式下运行的


## 64位,32位系统的区别
    CPU内部结构与寄存器
        CPU里面有很多电气单元的,有运算器,控制器,寄存器
        例如寄存器有
            4位寄存器 
            8位寄存器  al bl
            16位寄存器 ax bx
            32位寄存器 eax ecx
            64位寄存器 reax rebx
        寄存器越大,那么能计算的数越大
        为了保证CPU的向下兼容性,
        32位CPU有 32位寄存器 16位寄存器 8位寄存器 4位寄存器 (最大寄存器是32位的)
        64位CPU有 64位寄存器 32位寄存器 16位寄存器 8位寄存器 4位寄存器 (最大寄存器是64位的)
    
        操作系统是c语言写完编译的
        所以32位操作系统是在32位CPU下编译的，是可以运行在64位CPU下的 但是发挥不出来64位CPU的计算能力
        但是64位操作系统是在64位CPU下编译的,是不可以运行在32位CPU下的，因为32位CPU没有64位的寄存器
    
        所以同样的c语言代码可能在32位操作系统与64位操作系统运行的结果可能不一样

## RISC与CISC CPU架构
    20%的指令位常用指令,在一个程序执行的时候会调用比例达到80%
    80%的指令位不常用指令,在一个程序执行的时候调用比例为20%
    
    RISC精简指令集 
        比如大部分的手机使用ARM体系指令集就是精简指令集
        把常用的指令放到CPU中 不常用的指令去除 不常有指令的功能用软件去实现
        例如把mp3的指令放到CPU中,就不需要写程序调mp3直接就可以使用指令来操作
    CISC复杂指令,一般来讲x86构架的cpu都是复杂指令集,AMD,intel就是x86构架的
        linux就是基于x86的操作系统
    SPARC, x86与ARM
        Sun有自己的CPU,就是基于SPARTC,其实就是一款RISI的CPU

## 汇编语言
    I386汇编简介
        mov eax, 10
        add eax, 10
        sub eax 20
        call printf
    VS反汇编
        先F9设置一个断点
        F5,用调试方法运行代码
    IDE工具
    QT常用快捷键
        Ctrl + /
    VS常用快捷键
        断点F9
    VS断点,调试

## 常量
    常量就是在程序中不可变化的量,常量在定义的时候必须给一个初始值
    #define 定义一个宏常量
    const 定义一个const常量
    
    字符串常量
        “hello world”
    对于#define类型的常量,c语言的习惯是常量名称为大写,
    但对于普通const常量以及变量,一般为小写结合大写的方式.
    
    例子
        #include <stdio.h>
        #define MAX 10 //定义一个宏常量，值为10
        int main(){
            printf("%d\n", 10);
            printf("%d\n", MAX);
            const int i = 100;
            printf("%d\n", i);
            return 0;
        }

## 二进制数, 位, 字节与字
    我们习惯于十进制的数: 10, 12等
    一个位只能表示0,或者1两种状态简称bit
    一个字节为8个二进制,称为８位,简称BYTE(8bit)
    一个字为２个字节,简称WORD(16bit)
    两个字为双字,简称DWORD(32bit)

## 八进制
    八进制以8为基数的数制系统,c语言当中0表示八进制,0666;

## 十六进制
    十六进制值16为基数的数值系统,c语言中用0x表示十六进制
    十进制	二进制	八进制	十六进制
    0	0	0	0
    1	1	1	1
    2	10	2	2
    3	11	3	3
    4	100	4	4
    5	101	5	5
    6	110	7	6
    7	111	7	7
    8	1000	10	8
    9	1001	11	9
    10	1010	12	a
    11	1011	13	b
    12	1100	14	c
    13	1101	15	d
    14	1110	16	e
    15	1111	17	f
    16	10000	20	10
    17	10001	21	11
    二进制与八进制和十六进制是一一对应的,二进制转八进制(按三位分组，单独计算,拼接)二进制转十六进制(按四位分组，单独计算,拼接)
    十进制转八进制,用十进制数作为被除数,8做为除数,取商数和余数,直到商数为0的时候,将余数倒过来就是转换的结果
    十进制转八进制,用十进制数作为被除数,16做为除数,取商数和余数,直到商数为0的时候,将余数倒过来就是转换的结果

## 原码
    将最高为数为符号位(0代表正, 1代表负),其余各位代表数值本身的绝对值
    +7的原码是  0000 0111
    -7的原码是   1000 0111
    +0的原码是  0000 0000
    -0的原码是　 1000 0000 

## 反码
    一个数如果为正,那么反码和原码相同
    一个数如果为负,那么符号为１,其他各位与原码相反
    +7的原码是  0000 0111
    -7的反码是　 1111 1000
    -0的反码是   1111 1111　

## 补码
    补码=反码+1 计算机数存的时候都是该数的补码

    原码和反码都不利于计算机的运算,如：原码表示的7和-7相加,还需要判断符号位.
    正数:原码,反码补码都相同
    负数:最高为１,其余各位原码取反,最后对整个数+1(也就是反码加1)
    补码符号位不动,其他为求反,最后整个数+1,得到原码
    
    用补码进行运算,减法可以通过加法来实现 
    ７-6=1
    7的补码和-6的补码相加: 0000 0111 + 1111 1010 = 1000 0001
    几位舍弃后,剩下的00000001 就是1的补码
    
    计算机数存的时候都是该数的补码
    内存的单位都是字节
    在32位操作系统和64位操作系统所有的类型都是不一样的
    
    无论是原码，反码，补码在转换的过程中最高位符号位不要动它
    无论是原码，反码，补码在转换的过程中先用sizeof判断当前类型是几个字节的在做转换

## sizeof 关键字
    sizeof 是c语言关键字,功能是求指定数据类型在内存中的大小,单位:字节
    一个整数在32位操作系统下,是4个字节，在嵌入式系统不一定
    一个整数在32位操作系统下,最大存储的数是2的32-1次方
    一个整数在64位操作系统下,最大存储的数是2的64-1次方
    为什么减1因为最高位是符号位
    
    size_t
    无论是原码，反码，补码在转换的过程中先用sizeof判断当前类型是几个字节的在做转换

## int类型
    int常量,变量
        int就是32位的一个二进制整数,在内存当中占据4个字节空间
    printf输出int值
        %d,　输出一个有符号的十进制整数
        %u, 代表输出一个无符号的十进制整数
    printf输出八进制和十六进制
        有一个概念是无论二进制，八进制和十六进制一定是固定写法,十进制才表达负数
        %x,代表输出十六进制数 
        ％Ｘ,用大写字母方式输出16进制数
        %o,代表输出八进制数
    short, long, long long, unsigned int
        short 意思为短整数,在32位操作系统下是２个字节，(16个比特)
        long意思为长整数,在32位操作系统下是４个字节，(３２个比特),在6４位系统下,windos还是４个字节，unix下称了8个字节,但这个也是不一定的
        int 不管是在32位系统下,还是64位系统下,无论是windows还是unix都是4个字节的
        long long 不管是在32位系统下,还是64位系统下,无论是windows还是unix都是8个字节的
        unsigned int 
        c语言所有的整数都可以加unsigned(无符号数的意思)
    
        一定要记住计算机存的是补码
        无论是原码，反码，补码在转换的过程中先用sizeof判断当前类型是几个字节的在做转换
        无符号数直接把这个数的补码当成正数输出了
            #include <stdio.h>
            int main(){
                printf("%d\n", 7);  //7
                printf("%u\n", -7); //4294967289
                return 0;
            }

## 整数溢出
    计算一个整数的时候超过整数能够容纳的最大单位后,整数会溢出,溢出的结果是高位舍弃，符号位丢失
    当一个小的整数赋值给大的整数,符号位不丢失,会继承

## 大端对齐与小端对齐
    内存都是以字节为单位的 8个bit
    int a = 0x12345678; 怎么看这句代码呢 4个bit可以把16进制的16个数字包括,所以a的每个数字占4个bit
        所以a放到内存中的时候是2个数字放在一个内存的字节里面 12 34 56 78
        
    对于arm，intel这种x86构架的复杂指令CPU,整数在内存中是倒者存放的,低地址放低位,高地址放高位,小端对齐.
        78    56  34  12
        低地址        高地址
    但对于unix服务器的CPU,更多是采用大端对齐的方式存放整数

## char类型
    char常量,变量 
        char c; 定义一个char变量
        ＇a＇,char的常量
        char的本质就是一个整数,一个字节大小的整数,相当于byte
    printf输出char
        ％c意思是输出一个字符,而不是一个整数
    不可打印char转义字符
        \a,报警
        \b,退格 退一格并且把前面的一个字符擦掉
        \n,换行 
        \r,回车 会退到这一行的最前段,并且把第一个字符擦掉
        \t,制表符
        \\,斜杠
        \’单引号
        \”双引号
        \?问好
    char和unsigned char
        char取值范围为-128到127
        unsigned char 为0-255

## 浮点float，double,long double类型
    浮点常量,变量
    float 在32位系统下是４个字节,double在32位系统下是8个字节
    小数的效率很低,避免使用,除非明确的要计算一个小数
    
    printf输出浮点数
        %f是输出一个double
        %lf输出一个long double
    
    如何对浮点数进行四舍五入？浮点数+0.5 然后直接按照整数一般的运算

## 类型限定
    const
        const 是代表一个不能改变值的常量
    volatile
        代表变量是一个可能被CPU指令之外的地方改变的,编译器就不会针对这个变量去优化目标代码.
    register
        变量在CPU寄存器里面,而不是在内存里面.但register是建议型的指令,而不是命令型的指令

## 字符串在计算器内部的存储方式
    字符串是内存中一段连续的char空间,以”\0”结尾
    “”是c语言表达字符串的方式

​	printf格式字符

| 字符 | 对应的数据类型     | 含义                                                         |
| :--- | :----------------- | :----------------------------------------------------------- |
| d    | int                | 接受整数数值并将它表示为有符号的十进制整数                   |
| hd   | short int          | 短整数                                                       |
| hu   | unsigned short int | 无符号短整数                                                 |
| o    | unsigned int       | 无符号的8进制整数                                            |
| u    | unsigned int       | 无符号的10进制整数                                           |
| x/X  | unsigned int       | 无符号的16进制整数,x对应的是abcdef,X对应的是ABCDEF           |
| f    | float或double      | 单精度浮点数或双精度浮点数                                   |
| e/E  | double             | 科学技术法表示数,此处e的大小写在输出时用e的大小写            |
| c    | char               | 字符型,可以把输入的数字按照ASCII码相应转换为对应的字符       |
| s/S  | char */wchar_t     | 字符串,输出字符串的字符直至字符串的空字符(字符串以’\0’结尾,这个＇\０＇即是空字符) |
| p    | void *             | 以16进制形式输出指针                                         |
| %    | %                  | 输出一个百分号                                               |

​	Printf　附加格式

| 字符            | 含义                                                      |
| --------------- | --------------------------------------------------------- |
| l               | 附加在d,u,x,o表示长整数                                   |
| －              | 左对齐                                                    |
| m(代表一个整数) | 数据最小宽度                                              |
| ０              | 将输出前面补上0,直接占满指定列宽为止（不可以搭配使用”-”） |
| N代表一个整数   | 宽度至少为n位,不够空格填充                                |

​	putchar是显示一个字符的函数

​	scanf函数与getchar函数
​		scaf通过键盘读取用户输入,放入变量中,记得参数一定是变量的地址(&)
​		getchar得到用户键盘输入的字符

## 运算符表达式和语句
    基本运算符
        =
            数据对象:泛指数据内存的存储区域
            左值:表示可以被更改的数据对象
            右值:能赋值给左值的量
        + - * / % += -= *= /= %= 
        ++自加1	
            i++先计算表达式的值,然后再++
            ++i是先++，再计算表达式的值
        --
        逗号运算符
            逗号表达式先求逗号左边的值,然后求右边的值,整个语句的值是右边的值
        	int a = 2;
            int b = 3;
            int c = 4;
            int d = 5;
            int i = (a = b, c + d);
​	运算符的优先级

| 优先级 | 运算符                                                       | 结合性   |
| ------ | ------------------------------------------------------------ | -------- |
| １     | ＋＋(后缀),--(后缀),()(调用函数),{}(语句块),.,->             | 从左到右 |
| ２     | ++(前缀),--(前缀),+(前缀),-(前缀),!(前缀),sizeof,*(取指针值),&(取地址),type(类型转化) | 从右到左 |
| ３     | *, /, %                                                      | 从左到右 |
| ４     | ＋，－                                                       | 从左到右 |
| ５     | << >>                                                        | 从左到右 |
| ６     | < > <= >=                                                    | 从左到右 |
| 7      | == !==                                                       | 从左到右 |
| 8      | ＆                                                           | 从左到右 |
| 9      | ＾                                                           | 从左到右 |
| 10     | ｜                                                           | 从左到右 |
| 11     | ＆＆                                                         | 从左到右 |
| 12     | ｜｜                                                         | 从左到右 |
| 13     | ？                                                           | 从右到左 |
| 14     | =, *=, %=, +=, -=, <<=,>>=,&=,\|=,^=                         | 从右到左 |
| 15     | ，(逗号运算符)                                               | 从左到右 |

复合语句

​	｛｝代码块

空语句

​	只有一个;号的语句就是空语句,空语句在c语句里面是合法的,并且是在某些场合必用的　例如: for死循环

类型转化

​	double f = (double)3 / 2　　()为强制类型转化运算符


## 条件分支语句
    关系运算符
        在c语言中0代表false,　非0代表真
        < <= > >= == !=
    关系运算符优先级
        前四种相同,后两种相同,前四种高于后两种优先级
    逻辑运算符
        && || ! if 
        if else
        if else if
        switch 与 break,default
    多重选择
        什么时候用if, 什么时候用switch
        当条件很复杂,一个条件中有&&, ||, !存在,那么用if语句
        如果条件很简单, 但分支很多,那么适合用switch	
    条件运算符?
        一个求绝对值的例子
            int i = -8;
            int x = ( i < 0) ? -i : i;
    goto语句和标号
        无条件跳转goto
        不建议使用goto语句,goto语句会使你的程序可读性很差

## 循环语句
    while
        while(条件),如果条件为真,循环继续,条件为假,循环结束
        while(1)是死循环
    continue
        循环遇到continue语句,不再执行continue下面的代码,而是直接返回循环起始语句处继续执行循环.
    break
        循环遇到break语句,立刻终端断开,循环结束
    do while
        do
            语句
        While(条件)
        对于do while来讲,循环的复合语句至少可以被执行一次
        对于while来讲,有可能复合语句一次执行机会都没有
    for
        for(;0;){}　一次都不会执行
        for(;1;){}　死循环
    循环嵌套

## 数组
    一维数组定义与使用
        int array[10];//定义了一个一维数组,名字叫array,一共有10个元素,每个元素都是int类型
    数组内存的存储方式
        数组在内存中就是一段连续的空间,每个元素的类型都是一样的
    一维数组初始化
        int array[10] = {1,2,3,4,5,6,7,8,9};
        int array[10] = {1,2,10};将数组前三个赋值为1,2,10,其余都为0
        int array[10] = { 0 };将数组的元素都置为0
    二维数组定义与使用
        int array[2][3];
    二维数组初始化
        int array[2][3] = { {1, 2, 3}, {4, 5, 6} };

## 字符串与字符数组
    字符数组定义
        char array[100];
    字符数组初始化
        char array[100] = { 'a','b','c','d' };
        char array[100] = "hello world";
        char array[100] = { 0 }; 空
        char array[] = "abcd"; //缺省用法　长度为5
    字符串一定是在内存中以0结尾的一个char数组
    
    字符数组使用
        Gbk 汉字占２个字节
        Utf8汉字占3个字节
        如果将一个字符串当做char处理,那么标准ASCII字符一定是一个正数,汉字的第一个字节一定是一个负数
    
    随机数产生函数rand和srand
        头文件 stdlib.h
        Rand是伪随机数产生器,每次调用rand产生的随机数是一样的
        如果调用rand之前先调用srand就出现任意的随机数
        只要能保证每次调用srand函数的时候,参数的值是不同的,那么rand函数就一定会产生不同的随机数
        
        #include <stdio.h>
        #include <stdlib.h>
        #include <time.h>
    
        int main()
        {
            timer_t tm = time(NULL);
            srand(tm);
            int i;
            for(i = 0; i < 10; ++i){
    
                int value = rand();
                printf("%d\n", value);
            }
            return 0;
        }
    用scanf输入字符串
        scanf(“%s”, s) //注意数组的长度
        scanf(“%d”, &a)
    字符串的结束标志
        scanf将回车,空格都认为是字符串输入结束标志
    字符串处理函数
        gets
            char s[100] = { 0 };	
            gets(s);//gets认为回车的输入结束标示,空格不是输入结束标示,所以用gets这个函数就可以实现输入带空格的字符串
            gets不能类似”%s”或者”%d”之类的字符转义,只能接受字符串的输入
        fgets函数
            gets函数不检查预留缓冲区是否能够容纳用户实际输入的数据.多出来的字符会导致内存溢出,fgets函数改进了这个问题
            由于fgets函数是为读取文件设计的,所以读取键盘时没有gets那么方便
            
            char s[100] = { 0 };
            fgets(s, sizeof(s), stdin);
        puts 函数
            puts函数打印字符串,与printf不同,puts会在最后自动添加一个”\n”
        fputs是puts的文件操作版本
            fputs是puts的文件操作版本
            char s[] = “hello world”;
            fputs(s, stdout);
        strlen,字符串长度
            size_t strlen(const char * _Str);
            返回不包含字符串结尾’\０’的字符长度
        strcat 字符串追加
            size_t strcat(char * _Str1, const char * _Str2)
            将参数_Str2追加到_Str1后尾
        strncat,字符串有限追加
            size_t strncat(char * _Str1, const char * _Str2, size_t)
        strcmp,字符串比较
            int strcmp(const char * _Str1, const char * _Str2);
            比较两个字符串是否相等,相等返回0,不等返回非0
        strncmp,字符串有限比较
            int strcmp(str1, str2, 5);
        strcpy 字符串拷贝
            char *strcpy(char * _Str1, const char * _Str2);
            将参数_str2拷贝到参数_str1
        strncpy 字符串有限拷贝
        sprintf
            和printf函数功能类似,printf函数将格式化结果输出到屏幕,sprintf将格式化结果输出字符串
        sscanf函数
            sscanf类似与scanf函数,scanf从键盘读取用户输入,scanf指定格式化字符串读取输入
        strchr查找字符
            char * strchr(char * _str , int _Ch);
            在参数_str中查找参数_ch指定字符,找到返回字符_ch在_str中所在的位置，没有位置返回null
        strstr查找子串
            char * strstr(char * _str, const char * _substr);
            在参数_str中查找参数_substr指定子串,找到返回子串在_str中所在的位置,没有找到返回null
        strtok分割字符串
            字符在第一次调用的时strtok()必须给予参数s字符串,往后的调用则将参数s设置成null每次调用成功则返回指向被分割出片段的指针
                char buf[] = "abc@defg@igk";
                char *p = strtok(buf, "@");
                while (p) {
                    printf("%s\n", p);
                    p = strtok(NULL, "@");
                }
        atoi 转换为int
            需要包含头文件stdlib.h
        atof 转换为float
        atol 转换为long

## 函数
    函数的原型和调用
        在使用函数前必须定义或者声明函数　在mian() 函数之前
    函数的形参与实参
        在调用函数的时候,函数大多数都有参数,主调函数和被掉函数之间需要传递数据.
        在定义函数的时函数名后面括弧中的变量名称为＂形式参数＂,简称形参,在调用函数的名的后面括号中的变量或表达式称为”实际参数”,简称实参
        
            形参在未出现函数调用时,他们并不占用内存单元,只有在发生函数调用的时候形参才被分配内存,函数调用完后,形参所占的内存被释放
        实参可以是变量或者表达式
        在定义函数时,一定要指定形参的数据类型.
        形参与实参的数据类型一定要可兼容
        在Ｃ语言中,实参与形参的数据传递是”值传递”,即单向传递,只由实参传递给形参，而不能有形参传递给实参．
        如果函数的参数是个数组,那么是可以通过形参修改实参的值的
    函数的返回类型与返回值
        函数的返回值通过函数中的return获得,如果函数的返回值为void可以不需要return 语句.
        函数return 语句中的返回值数据类型应该与函数定义时相同
        如果函数中没有return语句,那么函数将返回一个不确定的值
    main函数与exit函数与函数return语句
        在main函数中调用return和调用exit的效果是一样的.
        在子函数中调用exit代表整个程序退出了,但子函数中调用return只是这个子函数退出了,程序还在运行．
    多个源代码文件程序的编译
        头文件的使用
            如果把main函数放在第一个文件中,而把自定义函数放在第二个文件中,那么就需要在第一个文件中声明函数的原型.
            如果函数原型包含在一个头文件里,那么不必每次使用函数的时候都声明其原型了．
            把函数声明放在头文件是很好的习惯
        ＃include 与 #define 的意思
            #include就是简单的文本内容的替换
            #define就是简单的文本替换而已
        ＃ifndef 与　#endif
            #ifndef的意思就是条件预编译,如果#ifndef后面的条件成立，那么就预编译从＃ifndef开始到#endif之间的代码,否则不会预编译这段代码
    函数的递归
        递归的过程
        void test(int n){
            if(n > 0){
                printf("先序递归 n = %d\n", n);// 先序递归 na me daima shi 顺序 zhixing de
                --n;
                test(n);//hanshu ziji diaoyong ziji
                printf("后序递归 n = %d\n", n); //后序递归 name daima shi 逆序 zhixing de
            }
        }
    
        int age(int n){
            if(n == 1)
                return 10;
            return age(n-1) + 2;
        }
    
        int main()
        {
            int i = 5;
            printf("age = %d\n", age(i));
            return 0;
        }
    
        将10进制数转化为二进制数的例子
        void bin(int n){
            int i = n % 2;
            if(n > 0){
                bin(n / 2);
                printf("%d", i);
            }
        }
        斐波那契数列例子
        斐波那契数列指的是这样一个数列 0,1,1,2,3,5,8,13,21,34,55,89,144,...
        第０项是0,第1项是第一个1．
        这个数列从第２项开始,第一项都等于前两项之和．
        int fib(int n){
            if(n == 0){
                return 0;
            }else if(n == 1){
                return 1;
            }else{
                return fib(n-1) + fib(n-2);
            }
        }
        递归的优点
            递归给某些编程问题提供了最简单的方法
        递归的缺点
            一个有缺陷的递归会很快消耗计算机的资源,递归的程序难以理解和维护

## 指针
    指针变量也是一个变量(就是某个操作系统无符号的整数（十六进制）)
    指针存放的内容是一个地址,该地址指向一块内存空间
    指针变量的定义 可以定义一个指向一个变量的指针变量
        int *p; 表示定义一个指针变量	
        *p; 代表指针所指内存的实际数据
        切记，指针变量只能存放地址,不能将一个int型变量直接赋值给一个指针 例如 int *p = 100
    & 取地址运算符
        & 可以取得一个变量在内存当中的地址
    无类型指针	
        定义一个指针变量,但不能指定它指向具体哪种数据类型.可以通过强制转化将void *转化为其他类型指针,也可以用(void *)将其他类型指针强制转化为void类型指针 void *p
    NULL 空指针 
        NULL在c语言中定义为(void * )0 
        当一个指针不指向任何一个有效内存地址的时候,我们应该把指针设置为NULL.
        指向NULL的指针叫空指针
        没有指向任何变量地址的指针叫野指针,程序应该避免野指针的存在
    空指针与野指针
        指向NULL的指针叫空指针,　没有具体指向任何变量地址的指针叫野指针
    指针的兼容性
        指针之间赋值比普通数据类型赋值检查更为严格,例如：不可以把一个double	n *　赋值给int
        原则上一定是相同类型的指针向相同类型的变量地址,不能用一种类型的指针指向另一种类型的变量地址
    指向常量的指针与指针常量
        const char *p; 定义一个指向常量的指针 *p是个只读指针,不能修改这个内存的值
        char *const p; 定义一个指针常量,一旦初始化之后其内容不可改变 指向一个固定地址　不能在换地址了
    指针与数组的关系
        一个变量有地址,一个数组包含若干个元素,每个元素在内存中都有地址.
            int a[10];
            int *p = a;
            比较p和＆a[0]的地址是否相同
    指针运算
        指针运算不是简单的整数加减法,而是指针指向的数据类型在内存中占用字节数做为倍数的运算．
            char *p;
            p++; 移动了sizeof(char)这么多的字节数
            int *p1;
            p1++; 移动了sizeof(int)这么多的字节数
        赋值　int *p = &a;
        求值　int i = *p;
        取指针地址　int **pp = &p;
        将一个整数加(减)给指针: p + 3; p - 3;
        增加(减少)指针值p++, p--
     
        求差值，p1 - p2通常用于同一个数组内求两个元素之间的距离
        (强转的化可以得到两个元素指针相差的字节)
    
        比较p1 ==p2通常用来比较两个指针是否指向同一个位置
    
    两个地址相加没有任何意义
    两个地址强转相加也没意义
    通过指针使用数组元素
        p+1代表＆a[1],也可以直接使用p[1]表示a[1]
        p+5代表&a[5]
        p++
    指针数组
        int *p[5]
    指向指针的指针(二级指针)
        指针就是一个变量,既然是变量就也存在内存地址,所以可以定义一个指向指针的指针
        int i = 10;
        int *p = &i;
        int **p2 = &p;
        printf(“%d\n”, **p2);
        以此类推可以定义3级甚至多级指针.c语言允许定义多级指针,但是指针级数过多会增加代码的复杂度,考试的时候肯能会考多级指针,但实际编程的时候最多用到３级

指向二维数组的指针

| int buf [3 ][5]                    | 二维数组名称,buf代表数组首地址    |
| ---------------------------------- | --------------------------------- |
| Int (*a)[５]                       | 定义一个指向int[5]类型的指针变量a |
| a[0],*(a ＋ 0),*a                  | 0行,0列元素地址                   |
| a＋1                               | 第１行首地址                      |
| a[1], *(a＋1)                      | 第1行,　０列元素地址              |
| a[1]＋２,＊(a+1)+2,&a[1][2]        | 第1行,　２列元素地址              |
| ＊(a[1]+2),*(*(a + 1) +2), a[1][2] | 第1行,　２列元素的值              |

指针变量作为函数的参数
​    函数的参数可以是指针类型．它的作用是将一个变量的地址传送给另一个函数
​    通过函数的指针参数可以间接的实现形参修改实参的值

一维数组名作为函数的参数
    当数组名作为函数参数时,c语言将数组名解释为指针
    int func(int array[10])
    int func(int array[])
    int func(int *array)

二维数组名作为函数的参数
    二维数组做函数参数时可以不指定第一个下标
    int func(int array[][10])
    int func(int (*array)[10])
    将二维数组做函数参数用例不是特别多见

const关键字保护数组内容
    如果将一个数组做为函数的形参传递,那么数组内容可以在被调用函数内部修改,有时候不希望这样的事情发生,所以要对形参采用const参数
    func(const int array[])

指针作为函数的返回值
```c
int *test(){
    int a = 0;
    return &a;
}
```

指向函数的指针
    指针可以指向变量，数组，也可以指向一个函数．
    一个函数在编译的时候会分配一个入口地址,这个入口地址就是函数的指针,函数名称就代表函数入口地址．
    函数指针的定义方式,int (*p)(int);//定义一个指向int func(int n)类型函数地址的指针．
    1.定义函数的指针变量的形式为: 函数返回类型 (*指针变量名称)(参数列表)
    2.函数可以通过函数的指针调用
    3.int(*p)()代表指向一个函数,但不是固定哪一个函数
    在回调函数和运行期动态绑定的时候大量的用到了指向函数的指针

把指向函数的指针做为函数的参数
```c
将函数指针做为另一个函数的参数称为回调函数
int add(int a, int b){
    return a + b;
}

int max(int a, int b){
    return a > b ? a : b;
}

int main(){
    int i = func1(max, 6, 9);
    printf("i = %d\n", i);
    return 0;
}
```

memset,memcpy,memmove函数
    这三个函数分别实现内存设置,内存拷贝和内存移动
    使用memcpy的时候,一定要确保内存没有重叠区域
    ＃include <string.h>

指针小结

| 定义         | 说明                                                        |
| ------------ | ----------------------------------------------------------- |
| int　i       | 定义整形变量                                                |
| int *p       | 定义一个指向int的指针变量                                   |
| int a[10]    | 定义一个int数组                                             |
| int *p[10]   | 定义一个指针数组，其中每个数组元素指向了一个int型变量的地址 |
| int (*p)[10] | 定义了一个数组指针，指向int[10]类型的指针变量               |
| int func()   | 定义一个函数，返回值为int型                                 |
| int *func()  | 定义一个函数返回值为int *型                                 |
| int (*p)()   | 定义了一个指向函数的指针，函数原型为无参数，返回值为int     |
| int **p      | 定义一个指向int的指针的指针,二级指针                        |


字符指针与字符串
    指针和字符串
    在C语言当中,大多数字符串操作其实就是指针操作
    
    char s[] = “hello world”;
    char *p = s;
    c[0] = ‘a’;
    
    通过指针访问字符串数组
        char buf[100] = "Hello World";
        char *p = buf;
        //*(p + 5) = 'a';
        //p[5] = 'b';
        p += 5;
        *p = 'c';
        p[3] = ' ';
        printf("buf = %s\n", buf);
    
    函数的参数为char *
        void print_str(char *s){
            int i = 0;
            while(s[i]) {
                printf("%c", s[i++]);
            }
        }
    
    指针数组做为main函数的形参
        int main(int argc, char *argv[])
        main函数是操作系统调用的，所以main函数的参数也是操作系统在调用时候自动填写的
        argc　代表命令行的数量
        argv 代表命令行的具体参数,是char * 类型的

## 内存管理
    作用域
        一个c语言变量的作用域可以是代码块，作用域，函数作用域或者文件作用域．
        代码块是{}之间的一段代码
        出现在{}之外的变量,就是全局变量
    auto自动变量
        一般情况下代码块内部定义的变量都是自动变量．当然也可以显示的使用aotu关键字
    register寄存器变量
        通常变量在内存当中,如果能把变量放到ＣPU的寄存器里面，代码执行效率会更快
        register int i;
        对于一个寄存器变量是不能取地址的，因为寄存器没有地址
    代码作用域的静态变量
        静态变量是指内存位置在程序执行期间的一值不改变的变量,一个代码块内部的静态变量只能被这个代码块内部访问
    代码块作用域外的静态变量
        代码块之外的静态变量在执行期间一直存在,但只能被定义这个变量的文件访问
    全局变量
        全局变量的存储方式和静态变量相同,但可以多个文件修改
    外部变量与extern关键字
        extern int i;
    全局函数和静态函数
        在c语言中函数默认是全局的,使用关键字static可以将函数声明为静态的
    内存四区（当然不止这四种区
        代码区
            代码区code，程序被操作系统加载到内存的时候，所有的可执行代码都加载到代码区，也叫代码段，这块内存是不可以在运行期间修改的
        静态区
            所有的全局变量以及程序中的静态变量都存储到静态区，比较如下两段代码的区别
        栈区
            栈stack是一种先进后出的内存结构,所有的自动变量，函数的形参都是要由编译器自动放出栈中，当一个自动变量超出其作用域时,自动从栈中弹出
            对于自动变量，什么时候入栈，什么时候出栈，是不需要程序控制的,由c语言编译器实现
            栈不是很大，一般都是以Ｋ为单位的 （动态的，与操作系统有关系）
            栈溢出　当栈空间已满，但还往栈内存压变量，这个就叫栈溢出
            对于一个32位操作系统,最大管理４G内存,其中１Ｇ是给操作系统自己用的，剩下３Ｇ都是给用户程序,一个用户程序理论上可以使用3Ｇ内存空间
        堆区
            堆heap和栈一样，也是一种在程序运行过程中可以随时修改的内存区域，但没有栈那样先进后出的顺序．
            堆是一个大容器，它的容量要远远大于栈，但是在c语言中,堆内存空间的申请和释放需要手动通过代码来完成．

    堆的分配和释放
        操作系统在管理内存的时候，最小单位不是字节,而是内存页
    mallocc
        void *malloc(size_t _Size)
        malloc函数在堆中分配参数_Size指定大小的内存,单位:字节,函数返回void *指针
    free
        void free(void *p)
        free负责在堆中释放malloc分配的内存.参数p为malloc返回的堆中内存地址
    calloc
        void * calloc(size_t _Count, size_t _Size);
        calloc与malloc类似，负责在堆中分配内存
        第一个参数是所需内存单元数量，第二个参数是每个内存单元的大小(单位: 字节),calloc自动将分配的内存置0
    realloc
        重新分配用malloc或者calloc函数在堆中分配内存空间的大小
        void * realloc(void *p, szie_t _NewSzie);
        第一个参数p为之前用malloc或者calloc分配的内存地址，＿NewSize为重新分配内存的大小,单位：字节．
        成功返回新分配的堆内存地址,失败返回NULL
        如果参数p的等于NULL，那么realloc与malloc一致

## 结构体，联合体，枚举与typedef
    结构体
        定义结构体struct和初始化
        访问结构体成员
            .操作符
        结构体的内存对齐模式
            编译器在编译一个结构的时候采用内存对齐模式
            结构体在内存中是个矩形，而不是一个不规则的形状
            它总是按偶数位来排列, 2,4,8.......
        指针结构体元素的位字段
            定义一个结构体的时候可以指定具体元素的位长(bit)
            struct test{
                char a : 2 //指定元素为２个位长,不是２个字节长
            }
            结构体可以用指针来使用，可以充分利用内存，可以达到一点的不浪费内存
            ＂也就是说把结构体当做为一块内存，只要是内存指针可以指＂
        结构数组
            struct man m[10] = { {＂t om＂, 12},  {＂marry＂, 12},  {＂jack＂, 12}, };
        嵌套结构
            一个结构体的成员还可以是另一个结构体
        结构体的赋值
            struct name a = b;
            结构体赋值，其实就是结构体之间内存的拷贝
        指向结构体的指针
            ->操作符
        指向结构体数组的指针
        结构中的数组成员和指针成员
            一个结构体可以有数组成员，也可以有指针成员，如果是指针成员结构体成员在初始化和赋值的时候就需要提前为指针成员分配内存
        在堆中创建结构体
            struct man{
                char *name;
                int age;
            };
            struct man *s = malloc(sizeof(struct name)*2);
            s[0].name = malloc(10*sizeof(char));
            s[1].name= malloc(10*sizeof(char));
        将结构体作为函数参数
            将结构作为函数的参数
            将结构指针作为函数的参数
        结构，还是指向结构的指针
            在定义一个和结构有关的函数，到底是使用结构，还是结构的指针？
            指针作为参数，只需要传递一个地址，所以代码效率高
            结论就是一个结构作为函数的参数时候，尽量使用指针，而不是使用结构变量，这样代码效率高
    联合体
        联合union是一个能在同一个存储空间存储不同类型数据的类型
        联合体所占的内存长度等于其最长成员的长度，也叫做共用体
        联合体虽然可以有多个成员，但同一时间只能存放其中一种
        #include <stdio.h>
        #include <stdlib.h>
        union A{
            char a;
            char *b;
        };
        int main(void){
            union A a;
            a.b = malloc(100);
            free(a.b);//要先free掉不然是不行的
            a.a = 10;
            printf("b = %d\n", a.a);
            return 0;
        }
    枚举
        枚举定义
            可以使用枚举(enumerated type)声明代表整数常量的符号名称,关键字enum创建一个新的枚举类型
            实际上,enum常量是int类型的
        默认值
            默认时，枚举列表中的常量被指定为０,1,2等
            可以指定枚举中具体元素的值
            enum spectrum { red = 10, yellow = 20}
    typedef
        typedef是一种高级数据特性，它能使某一类型创建自己的名字
        typedef unsigned char BYTE
            1.与#define不同,typedef仅限于数据类型,而不能是表达式或具体的值
            2.typedef是编译器处理的,而不是预编译指令
            3.typedef比#define更灵活
                直接看typedef好像没什么用处,使用BYTE定义一个unsigned char．使用typedef可以增加程序的可移植性.
        通过typedef定义函数指针
            #include <stdio.h>
            #include <string.h>

            char *mystrcat(char *s1, char *s2){
                strcat(s1, s2);
                return s1;
            }

            typedef char *(*STRCAT)(char *, char *);

            char *test(STRCAT p, char *s1, char *s2){
                return p(s1, s2);
            }

            int main(void){
                //char *(*p[10])(char *s1, char *s2);
                STRCAT array[10];

                char s1[100] = "hello";
                char s2[100] = "world";
                char *s = test(mystrcat, s1, s2);
                printf("s = %s\n", s);
                return 0;
            }

## 文件操作
    fopen
        r　以只读的方式打开文件,该文件必须存在
        r+ 以可读写的方式打开文件, 该文件必须存在
        rb+　读写打开一个二进制文件，允许读写数据，文件必须存在
        rw+ 读写打开一个文本文件,允许读和写
        w打开只写文件，若文件存在则文件长度清为０，即该文件内容会消失．若文件不存在则建立该文件
        w+ 打开可读写的文件，若文件存在则文件的长度清为０，即该文件内容会消失若文件不存在则建立该文件
        a 以附加的方式打开只写文件．若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加载到文件尾，即文件原先的内容会被保留
        a+ 以附加的方式打开可读写的文件．若文件不存在，则会建立该文件，如果文件存在，写入的数据会被到文件的末尾后，即文件原先的内容会保留
    二进制和文本模式区别
        FILE *p = fopen(＂D:\\temp\\a.txt＂,”w”) //文本模式
        FILE *p = fopen(＂D:\\temp\\a.txt＂,”wb”) //二进制模式
        1.在windows系统中，文本模式下,文件＂\r\n＂	代表换行．若以文本模式打开文件，并用fputs等函数写入换行符＂\n＂时，函数会自动在”\n”前面加上”\r”.即实际写入文件的是”\r\n”.
        2.在类Unix/Linux系统中文本模式下，文本以”\n”代表换行．所以Linux系统中文本模式和二进制模式下并无区别
    fclose
        fclose关闭fopen打开的文件
    getc和putc函数 
        #include <stdio.h>
        #include <stdlib.h>
        #include <string.h>
        int main(void){
            FILE *p = fopen("./a.txt", "r");
            if(p == NULL){
                printf("error\n");
            }else{
                char c = 0;
                while((c = getc(p)) != EOF){
                    printf("%c", c);
                }
                fclose(p);
            }
            return 0;
        }	
        getc读取一个字符测
        putc 写一个字符

    EOF和feof函数文件结尾
        程序怎么才能知道是否已经到达文件结尾了呢？EOF代表文件结尾
        如果已经是文件尾，feof函数返回ture    //while(!feof(p)){}
    fprintf, fscanf, fgets, fputs函数
        这些函数都是通过FILE *来对文件进行读写
        都是针对文本文件的行读写函数
    stat函数
        ＃include <sys/stat.h>
        int stat(const char * _Filename, struct stat *_Stat)
        stat.st_size;//文件大小，单位：字节
        函数的第一个参数代表文件，第二个参数是struct stat结构
        得到文件的属性，包括文件建立的时间，文件的大小等信息
    fread和fwrite函数
        size_t fread(void *buffer, size_t size, size_t count, FILE *strem);
        size_t fwrite(const void *buffer, size_t size, size_t count, FILE *strem);
        注意：这个函数以二进制形式对文本进行操作，不局限于文本文件
        返回值：返回实际写入的数据块数目
    fread与feof
        注意以下代码的区别
        while(!feof(p)){
        fread(&buf, 1, sizeof(buf), p); //会多读一行出来
        }
        While(fread(&buf, 1, sizeof(buf), p))
    通过fwrite将结构保存到二进制文件中
    fseek函数
        int fseek(FILE * _File, long _Offset, int _Origin);
        函数设置文件指针stream的位置.如果执行成功，stream将指向以fromwhere为基准,偏移offset(指针偏移量)个字节的位置,函数返回0．如果执行失败则不改变stream指向的位置,函数返回一个非0值．
        实验得出，超文本末尾位置,还是返回０．往回偏移超出首位置，还是返回 - 1,请小心使用．　　
        第一个参数　stream为文件指针
        第二个参数 offset为偏移量，正数表示正向偏移，负数表示负向偏移
        第三个参数origin设定从文件的哪里开始偏移，可能取值为: SEEK_CUR, SEEK_END或SEEK_SET
        SEEK_SET：　文件开头
        SEEK_CUR：　当前位置
        SEEK_END:   文件的结尾
        fseek(fp, 3, SEEK_SET);
    ftell函数
        函数ftell用于得到文件位置的指针当前位置相对于文件首的偏移字节数．在随机方式存取文件时，由于文件位置频繁的前后移动，程序不容易确定文件的当前位置．
        long len = ftell(fp)
    fflush函数
        c语言所有的文件操作函数都是缓冲区函数
        fflush函数可以将缓冲区任何未写入的数据写入文件中，
        成功返回０,失败返EOF 
        int fflush(FILE * _File)
        优势:不会因为停电，或者电脑司机等故障导致缓冲区的内容丢失
        不好的，硬盘读写次数增加，导致程序效率低，同时硬盘寿命变短
        修改配置文件的时候，有时候会使用，或者做一些不经常修改的数据，但很重要数据，那么用fflush
    remove函数
        remove 函数删除指定文件
        int remove(count char * _Filename);
        参数filename为指定的要删除的文件名，如果是windows下文件名与路径可以用反写杠\分割,也可以用斜杠/分割
    rename函数
        rename函数将指定文件改名
        int rename(const char *_OldFilename, const char * _NewFilename);
        参数oldFilename为指定的要修改的文件名字，newfilename为修改后的文件名.如果是windows下文件名与路径可以使用反斜杠\分割，也可以用斜杠/分割

## 基础数据结构与算法
    什么是数据结构
        数据（data）是对客观事物符号的表示，在计算机中是指所有能输入的计算机并被计算机程序处理的数据总称
        数据元素(data element)是数据的基本单位,在计算机中通常作为一个整体进行处理
        数据对象(data object)是性质相同的数据元素的集合,是数据的一个子集
        数据结构（data structure）是相互之间存在一种或多种特定关系的数据元素的集合．
        数据类型(data type)是和数据结构密切关系的一个概念，在计算机语言中,每个变量，常量或者表达式都是一个所属的数据类型
        抽象数据类型(abstract data type ADT)是指一个数据模型以及定义在该模型上的一组操作,抽象数据类型的定义仅取决于它的一组逻辑性,与其在计算机内部如何表示以及实现无关
    什么是算法
        算法是特定问题求解的一种描述,它是指令的有限序列,其每一条指令表示一个或多个操作，算法还有以下特性:
        有穷性：
            一个算法必须总是在执行有限步骤后的结果，而且每一步都可以在有限的时间内完成．
        确定性:
            算法中每一条指令都有确切的含义,读者理解时不会产生二义性，在任何条件下，算法只有唯一的条件执行路径，即相同的输入只能得出相同的输出．
        可行性:
            一个算法是可行的,即算法中描述的操作都可以通过已经实现的基本算法来实现的．
        输入:
            一个算法有零个或者多个输入,这些输入取自与某个特定对象的集合．
        输出：
            一个算法有一个或多个输出,这些输出或输入有某些特定关系的量
    排序
        冒泡排序
        选择排序
            #include <stdio.h>

            void swap(int *a, int *b){
                int tmp = *a;
                *a = *b;
                *b = tmp;
            }

            void bubble(int *array, int n){
                int i;
                int j;
                for(i = 0; i < n; ++i){
                    for(j = 1; j < n - i; ++j){
                        if(array[j-1] > array[j]){
                            swap(&array[j-1], &array[j]);
                        }
                    }
                }
            }

            void print_array(int *array, int n){
                int i;
                for(i = 0; i < n; ++i){
                    printf("array[%d] = %d\n", i, array[i]);
                }
            }

            int minkey(int *array, int low, int high){
                int min = low;
                int key = array[low];
                int i;
                for(i = low + 1; i < high; i++){
                    if(key > array[i]){
                        key = array[i];
                        min = i;
                    }
                }
                return min;
            }

            void select(int *array, int n){
                int i;
                for(i = 0; i < n; ++i){
                    int j = minkey(array, i, n);
                    if(i != j){
                        swap(&array[i], &array[j]);
                    }
                }
            }

            int main(int argc, char *argv[])
            {
                int array[10] = {32, 35, 76, 21, 56, 85, 23, 89, 15, 4};
                //bubble(array, 10);
                select(array, 10);
                print_array(array, 10);
                return 0;
            }
    查找
        顺序查找
            顺序查找的过程为,从表的最后一个记录开始，逐个进行记录的关键字和给定值比较,如果某个记录的关键字与给定值相等,则查找成功,反之则表明中没有所查找记录，查找失败
        二分查找
            在一个已经排序的顺序中查找,可以使用二分查找来实现
            二分查找的过程是，向确定待查记录所在的范围（区间）,然后逐步缩小查找范围,直到找到或者找不到该记录为止
            假设指针low和high分别指示待查找的范围下届和上届,指针mid指示区间的中间值,即
    链表
        单向链表定义
            对于数组,逻辑关系上相邻的两个元素的物理位置也是相邻的，这种结构的优点是可以随机存储任意位置的元素，但缺点是如果从数组中间删除或插入元素时候，需要大量移动元素，效率不高．
            链式存储结构特点，元素的存储单元可以是连续的，也可以是不连续的，因此为了表示每个元素a,与其接后的元素a+1之间的关系，对于元素a，除了存储其本身信息外，还需要存储一个指示其接后元素的位置．这两部分数据成为结点（node）
            一个结点中存储的数据元素被称为数据域．存储后存储位置的域叫指针域.n个结点(ai(1<=i<=n))的存储映像链接成一个链表．
            整个链表必须从头结点开始进行，头结点的指针指向下一个结点的位置，最后一个结点的指针指向NULL.
            在链表中,通过指向接后结点位置的指针实现将链表中的每个结点”链”到一起．链表中第一个结点称之为头结点．

# c语言提高

## 目标
接口的封装和设计(功能和抽象封装)
    接口api的使用能力
    接口api的查找能力(快速上手)
    接口api的实现能力
建立正确程序运行内存布局图(印象图)
    内存四区模型图
    函数调用模型图
代码
```c
    #ifndef SOCKET_CLIENT_H

    #define SOCKET_CLIENT_H

    //第一套api函数
    //socket客户端环境初始化
    int socketClientInit(void **handle);

    //socket客户端报文发送
    int socketClientSend(void *handle, unsigned char *buf, int bufLen);

    //socket客户端报文接收
    int socketClientReceive(void *handle, unsigned char *buf, int *bufLen);

    //socket客户端报文释放
    int socketClientDestory(void *handle);

    //第二套api函数
    //socket客户端环境初始化
    int socketClientInit2(void **handle);

    //socket客户端报文发送
    int socketClientSend2(void *handle, unsigned char *buf, int bufLen);

    //socket客户端报文接收
    int socketClientReceive2(void *handle, unsigned char **buf, int *bufLen);

    //socket客户端报文释放
    int socketClientDestory2(void **handle);

    //技术分析
    //1级指针
    //2级指针
    //void **handle类型封装的概念 业务模型封装的概念

    #endif
```
## 内存四区的专题讲座

### 数据类型本质分析
数据类型概念
    类型是对数据的抽象
    类型相同的数据有相同的表示形式,存储格式以及相关操作
    程序中使用的所有数据必定属于某一种数据类型
    数据类型
        简单数据类型
            基本数据类型
                整型(int)
                浮点型(float,double)
                字符型(char)
                空类型(void)
            用户自定义类型 枚举类型(enum)
        结构类型
            数组([])
            结构(struct)
            联合(union)
            类(union)
        指针(*)
数据类型的本质思考
    思考数据类型和内存有关系吗?
    c/c++为什么会引入数据类型?
数据类型的本质
    数据类型可以理解为创建变量的模具(模子),是固定内存大小的别名
    数据类型的作用:编译器预算对象(变量)分配的内存大小
    如何求数据类型的大小 sizeof(int *)
    请问:数据类型可以有别名吗?数据类型可以自定义吗?
数据类型大小
数据类型别名
    typedef
    struct在使用时必须在前面加上struct
    如果给struct取别名后,那么使用的时候就不用加struct,直接用别名
    typedef不仅仅可以给复杂的数据类型起别名,也可以给普通的数据类型起别名
```c
    #include <stdlib.h>
    #include <stdio.h>
    #include <string.h>

    //数据类型的用途
    //数据类型本质:固定大小内存块的别名
    //b &b 数组数据类型 定义一个1数组类型 2数组指针 3数组类型和数组指针的关系 ===>压死初学者的三座大山 抛砖

    int main01(int argc, char const *argv[])
    {
        int a;//告诉c编译器分配4个字节的内存
        int b[10];//告诉编译器分配40个字节的内存
        printf("a分配的字节数:%lu \n", sizeof(a));
        printf("b[10]分配的字节数:%lu \n", sizeof(b));
        printf("b:%p, b+1:%p, &b:%p, &b+1:%p \n", b, b+1, &b, &b+1);
        //b:    0x7ffdb8b33420, 
        //b+1:  0x7ffdb8b33424, 
        //&b:   0x7ffdb8b33420, 
        //&b+1: 0x7ffdb8b33448

        //b+1 &b+1 结果不一样 //b &b所代表的数据类型不一样
        //b  代表数组首元素的地址
        //&b 代表的是整个数组的地址

        printf("sizeof(b):%lu ", sizeof(b));
        printf("sizeof(a):%lu ", sizeof(a));
        return 0;
    }

    struct Teacher
    {
        char name[64];
        int age;
    };

    typedef struct Teacher2
    {
        char name[64];
        int age;
    }Teacher2;
    //数据类型别名 typeof

    typedef int u32;

    int main(int argc, char const *argv[])
    {
        struct Teacher t1;
        t1.age = 31;
        
        Teacher2 t2;
        t2.age = 31;

        printf("u32:%lu \n", sizeof(u32));
        return 0;
    }
```
数据类型的封装
    void的字面意思是无类型,void *则为无类型指针,void *可以指向任何数据类型
    用法
        数据类型的封装
        int initHandEnv(void **handle);
        典型如内存操作函数memcpy和memset的函数原型分别为:
        void * memcpy(void * dest, const void * src， size_t len)        
        void * memset(void * buff, int c， size_t num)        
    用法
        void 修饰函数返回值和参数,仅表示无
        如果函数没有返回值,那么应该返回将其声明为void型
        如果函数没有参数,那么声明其参数为void
    void指针的意义
        c语言规定只有相同类型的指针可以相互赋值
        void *指针作为左值用于接收任意类型的指针
        void *指针作为右值赋值给其他指针需要强制类型转换
    不存在void类型的变量
        c语言没有定义void究竟是多大的内存别名
数据类型总结与扩展
    数据类型本质是固定大小的内存块
### 变量本质分析
变量概念
变量本质

### 程序的内存四区模型
内存四区模型
各区元素分析

### 函数调用模型
基本原理
内存四区模型和函数调用模型传递分析
提示学好c语言的关键
如何建立正确的程序内存导图

### 内存四区模强化训练
### 作业强化

## 指针基础
## 字符串
## 一维数组
## 二维数组
## 指针数组和数组指针
## 多维数组和多维指针
## 结构体
## 文件
## 链表
## 函数与指针
## 动态库的封装和设计

# c++
## 函数
## 引用
## 内联函数
## 函数重载
## 面向对象概念
## 类的封装
## 类的构造和析构
## new/delete
## 类的静态成员
## c++编译器对象管理模型分析
## 操作符重载及友元
## 类的继承与多态
## 虚函数
## 纯函数
## 多继承
## 函数模板
## 类模板
## IO流
## 异常
## c11新特性
## 设计模式
## STL
## 算法基础
## 链表顺序存储
## 链表链表存储
## 循环链表
## 双向链表
## 栈(顺序和链式)
## 队列(顺序和链式)
## 栈的应用
## 堆(顺序和链表)
## 树基本概念及遍历
## 二叉树(遍历,非递归遍历)
## 数据结构
## 排序算法
## 冒泡算法
## 选择算法
## 插入算法
## 快速算法
## 希尔算法
## 图论(深度优先搜索,广度优先搜索,最小度成树,最短路径)
## 动态存储管理(回收算法,分配算法)
## 查找(二叉排序树和平衡二叉树,B树和B+树,哈希表)
## 内排序和外排序,动态规划

# Linux基础编程
# Linux系统编程
# Linux网络编程
# Linux数据库编程
# QT系统编程
01 day01 9
# c
## 环境搭建
    gcc -v
    g++ -v
    make -v
    gdb -v
    IDE QT http://download.qt.io/archive/qt/
    配置windows unix以达到都可以运行

## include头文件包含
    include是要告诉编译器，包含一个头文件，
    在Ｃ语言当中，任何库函数调用都需要提前包含头文件
    
    <头文件>,代表让c语言编译器去系统目录下寻找相关的头文件.
        在linux下会到/usr/include/目录下找
    “头文件”,代表让c语言编译器去用户当前目录下寻找相关头文件
    
    如果是使用了一个c语言库函数需要的头文件,那么一定是＃include <>   
    如果使用了一个自定义的.h文件,那么一定是#include “”
    如果你把你自定义的.h文件也放到系统目录的/usr/include目录下那么可以使用 <>

## main函数
    main函数是Ｃ语言中的主函数,一个Ｃ语言的程序必须有一个主函数，也只能有一个主函数

## 注释
    //代表注释，就是一个文字说明，没有实质的意义,单行注释	是c++语言的注释方法
    /**/,对行注释,对行注释是标准Ｃ语言注释方法

## {}括号，程序题和代码块
    c语言所有函数的代码都是{}里面包着的

## 声明
    int a
    声明一个变量名字叫a, 对于c语言，变量的名称是可以自定义

## c语言自定义名字的要求
    可以使用大小写字母，下划线，数字，但第一个字母必须是字母或者下划线，
    字母区分大小写
    不能用c语言的关键字作为变量名称
    每一行，必须是分号结尾

## printf 函数
    printf是向标准输出设备输出字符串的
    如果要输出一个字符串：例如:printf(“hello world” );
    如果要输出一个整数,例如: printf(“%d”, 整数)
    Printf(“\n”); 会输出一个回车换行符

## return 语句
    一个函数遇到return 语句就终止了,　return是c语言的关键字

## System系统调用
    system库函数的功能是执行操作系统的命令或者运行指定的程序
    system库函数的调用需要include <stdlib.h> 
        例子
            #include <stdio.h>
            #include <stdlib.h>
            int main(){
                printf("hello world\n");
                system("cat a.c");
                return 0;
            }
    system返回值在windows和unix下的不同

    POSIX标准
        b.c:
            #include <stdio.h>
            int main(){
                printf("hello world\n");
                return 100; //主函数return 0一般代表成功的意思,-1代表失败的意思
            }
        a.c:
            #include <stdio.h>
            #include <stdlib.h>
            int main(){
                printf("hello world\n");
                int i = system("cat a.c");
                int b = system("./b");
                printf("%d\n", i);
                printf("%d\n", b); //windows是100 linux是25600
                printf("%x\n", b); //windows是64 linux是6400
                printf("i = %x\n", b / 0x100); //64
                printf("i = %d\n", b / 0x100); //在linux修改以下这个就得到和windows一样的
                //所有的操作系统就windows是最特殊的
                //所以linux写一套代码很多代码都是通用的
                //为什么不一样呢?POSIX标准
                return 0;
            }
        是c语言的代码一种标准和规范
        如果不符合POSIX，代码的运行结果是不一样的
        windows支持的很差
        所以我们在使用库和函数的时候要使用p开头的,符合POSIX标准
        比如在多线程的时候我们最好使用pthread_create



## C语言编译过程,gcc参数简介
    gcc -o a a.c
        在windows编译后是a.exe
        在linux编译后是a，linux是文件名,带不带扩展无所谓的
        生成后的名字自定义的,linux如果不起名字,就是a.out
    
    c语言编译过程
        .c文件－＞预编译－＞编译－＞链接－＞可执行程序
        还有c的库加上去
    
    -E预编译	
        gcc -Ｅ -o a1.c a.c
        预编译a.c文件,生成的目标文件名为a.e
        预编译是将include包含的头文件内容替换到c文件中,同时将代码中没有的注释部分删除
        例如 #include <stdio.h>是将/usr/include/stdio.h文件内容替换到c的文件的中

    -S汇编
        gcc -S -o a.s a1.c
        -S就是将c语言转化为汇编语言
    
    -c编译(小写的c)
        gcc -c -o a.o a.s
        将代码编译为二进制的机器指令,但是不能执行
        
    连接(小写的o)
        gcc -o c c.o
        比如printf这个函数是c语言第三方库函数，linux叫.so windows叫.dll
        连接就是将这个函数的二进制连接到我们的程序中一起,然后才能运行
        也就是将库打包到我们的程序中
        gcc没有任何参数,代表就是链接
    
    可以看出java不是这个过程,java编译后不是可执行文件,是一个字节吗文件
    所以java是解释性语言
    
    gcc这个软件命令是很多的命令可以有很多的参数，以上是常用的
        gcc --help
        man gcc

## 操作系统结构
    计算机内存分用户区和内核区
    用户区:普通用户运行在用户区
    内核区:操作系统运行在内核区域
    32位操作系统,最大内存为4G，操作系统占用1G，剩下3G给用户程序
    32为操作系统即使你的硬件内存是8G但是它的最大内存是4G,只能使用4G，所以浪费
    64位操作系统,可能根硬件有关系不一定是2的64次方，但是最大内存肯定是大于4G的

    用户模式
        应用程序都是运行在用户区域
    内核模式
        操作系统的内核,设备驱动程序,这些都在内核模式下运行的


## 64位,32位系统的区别
    CPU内部结构与寄存器
        CPU里面有很多电气单元的,有运算器,控制器,寄存器
        例如寄存器有
            4位寄存器 
            8位寄存器  al bl
            16位寄存器 ax bx
            32位寄存器 eax ecx
            64位寄存器 reax rebx
        寄存器越大,那么能计算的数越大
        为了保证CPU的向下兼容性,
        32位CPU有 32位寄存器 16位寄存器 8位寄存器 4位寄存器 (最大寄存器是32位的)
        64位CPU有 64位寄存器 32位寄存器 16位寄存器 8位寄存器 4位寄存器 (最大寄存器是64位的)

        操作系统是c语言写完编译的
        所以32位操作系统是在32位CPU下编译的，是可以运行在64位CPU下的 但是发挥不出来64位CPU的计算能力
        但是64位操作系统是在64位CPU下编译的,是不可以运行在32位CPU下的，因为32位CPU没有64位的寄存器

        所以同样的c语言代码可能在32位操作系统与64位操作系统运行的结果可能不一样

## RISC与CISC CPU架构
    20%的指令位常用指令,在一个程序执行的时候会调用比例达到80%
    80%的指令位不常用指令,在一个程序执行的时候调用比例为20%
    
    RISC精简指令集 
        比如大部分的手机使用ARM体系指令集就是精简指令集
        把常用的指令放到CPU中 不常用的指令去除 不常有指令的功能用软件去实现
        例如把mp3的指令放到CPU中,就不需要写程序调mp3直接就可以使用指令来操作
    CISC复杂指令,一般来讲x86构架的cpu都是复杂指令集,AMD,intel就是x86构架的
        linux就是基于x86的操作系统
    SPARC, x86与ARM
        Sun有自己的CPU,就是基于SPARTC,其实就是一款RISI的CPU

## 汇编语言
    I386汇编简介
        mov eax, 10
        add eax, 10
        sub eax 20
        call printf
    VS反汇编
        先F9设置一个断点
        F5,用调试方法运行代码
    IDE工具
    QT常用快捷键
        Ctrl + /
    VS常用快捷键
        断点F9
    VS断点,调试

## 常量
    常量就是在程序中不可变化的量,常量在定义的时候必须给一个初始值
    #define 定义一个宏常量
    const 定义一个const常量
    
    字符串常量
        “hello world”
    对于#define类型的常量,c语言的习惯是常量名称为大写,
    但对于普通const常量以及变量,一般为小写结合大写的方式.

    例子
        #include <stdio.h>
        #define MAX 10 //定义一个宏常量，值为10
        int main(){
            printf("%d\n", 10);
            printf("%d\n", MAX);
            const int i = 100;
            printf("%d\n", i);
            return 0;
        }

## 二进制数, 位, 字节与字
    我们习惯于十进制的数: 10, 12等
    一个位只能表示0,或者1两种状态简称bit
    一个字节为8个二进制,称为８位,简称BYTE(8bit)
    一个字为２个字节,简称WORD(16bit)
    两个字为双字,简称DWORD(32bit)
    
## 八进制
    八进制以8为基数的数制系统,c语言当中0表示八进制,0666;

## 十六进制
    十六进制值16为基数的数值系统,c语言中用0x表示十六进制
    十进制	二进制	八进制	十六进制
    0	0	0	0
    1	1	1	1
    2	10	2	2
    3	11	3	3
    4	100	4	4
    5	101	5	5
    6	110	7	6
    7	111	7	7
    8	1000	10	8
    9	1001	11	9
    10	1010	12	a
    11	1011	13	b
    12	1100	14	c
    13	1101	15	d
    14	1110	16	e
    15	1111	17	f
    16	10000	20	10
    17	10001	21	11
    二进制与八进制和十六进制是一一对应的,二进制转八进制(按三位分组，单独计算,拼接)二进制转十六进制(按四位分组，单独计算,拼接)
    十进制转八进制,用十进制数作为被除数,8做为除数,取商数和余数,直到商数为0的时候,将余数倒过来就是转换的结果
    十进制转八进制,用十进制数作为被除数,16做为除数,取商数和余数,直到商数为0的时候,将余数倒过来就是转换的结果

## 原码
    将最高为数为符号位(0代表正, 1代表负),其余各位代表数值本身的绝对值
    +7的原码是  0000 0111
    -7的原码是   1000 0111
    +0的原码是  0000 0000
    -0的原码是　 1000 0000 

## 反码
    一个数如果为正,那么反码和原码相同
    一个数如果为负,那么符号为１,其他各位与原码相反
    +7的原码是  0000 0111
    -7的反码是　 1111 1000
    -0的反码是   1111 1111　

## 补码
    补码=反码+1 计算机数存的时候都是该数的补码

    原码和反码都不利于计算机的运算,如：原码表示的7和-7相加,还需要判断符号位.
    正数:原码,反码补码都相同
    负数:最高为１,其余各位原码取反,最后对整个数+1(也就是反码加1)
    补码符号位不动,其他为求反,最后整个数+1,得到原码

    用补码进行运算,减法可以通过加法来实现 
    ７-6=1
    7的补码和-6的补码相加: 0000 0111 + 1111 1010 = 1000 0001
    几位舍弃后,剩下的00000001 就是1的补码

    计算机数存的时候都是该数的补码
    内存的单位都是字节
    在32位操作系统和64位操作系统所有的类型都是不一样的

    无论是原码，反码，补码在转换的过程中最高位符号位不要动它
    无论是原码，反码，补码在转换的过程中先用sizeof判断当前类型是几个字节的在做转换

## sizeof 关键字
    sizeof 是c语言关键字,功能是求指定数据类型在内存中的大小,单位:字节
    一个整数在32位操作系统下,是4个字节，在嵌入式系统不一定
    一个整数在32位操作系统下,最大存储的数是2的32-1次方
    一个整数在64位操作系统下,最大存储的数是2的64-1次方
    为什么减1因为最高位是符号位

    size_t
    无论是原码，反码，补码在转换的过程中先用sizeof判断当前类型是几个字节的在做转换

## int类型
    int常量,变量
        int就是32位的一个二进制整数,在内存当中占据4个字节空间
    printf输出int值
        %d,　输出一个有符号的十进制整数
        %u, 代表输出一个无符号的十进制整数
    printf输出八进制和十六进制
        %x,代表输出十六进制数
        ％Ｘ,用大写字母方式输出16进制数
        %o,代表输出八进制数
    short, long, long long, unsigned int
        short 意思为短整数,在32位操作系统下是２个字节，(16个比特)
        long意思为长整数,在32位操作系统下是４个字节，(３２个比特),在6４位系统下,windos还是４个字节，unix下称了8个字节
        int 不管是在32位系统下,还是64位系统下,无论是windows还是unix都是4个字节的
        long long 不管是在32位系统下,还是64位系统下,无论是windows还是unix都是8个字节的
        unsigned int 
        c语言所有的整数都可以加unsigned(无符号数的意思)

        一定要记住计算机存的是补码
        无论是原码，反码，补码在转换的过程中先用sizeof判断当前类型是几个字节的在做转换
        无符号数直接把这个数的补码当成正数输出了
            #include <stdio.h>
            int main(){
                printf("%d\n", 7);  //7
                printf("%u\n", -7); //4294967289
                return 0;
            }

## 整数溢出
    计算一个整数的时候超过整数能够容纳的最大单位后,整数会溢出,溢出的结果是高位舍弃
    当一个小的整数赋值给大的整数,符号位不丢失,会继承

## 大端对齐与小端对齐
    对于arm，intel这种x86构架的复杂指令CPU,整数在内存中是倒者存放的,低地址放低位,高地址放高位,小端对齐.
    但对于unix服务器的CPU,更多是采用大端对齐的方式

## char类型
    char常量,变量 
        char c; 定义一个char变量
        ＇a＇,char的常量
        char的本质就是一个整数,一个字节大小的整数,
    printf输出char
        ％c意思是输出一个字符,而不是一个整数
    不可打印char转义字符
        \a,报警
        \b,退格
        \n,换行
        \r,回车
        \t,制表符
        \\,斜杠
        \’单引号
        \”双引号
        \?问好
    char和unsigned char
        char取值范围为-128到127
        unsigned char 为0-255

## 浮点float，double,long double类型
    浮点常量,变量
    float 在32位系统下是４个字节,double在32位系统下是8个字节
    小数的效率很低,避免使用,除非明确的要计算一个小数

    printf输出浮点数
        %f是输出一个double
        %lf输出一个long double

## 类型限定
    const
        const 是代表一个不能改变值的常量
    volatile
        代表变量是一个可能被CPU指令之外的地方改变的,编译器就不会针对这个变量去优化目标代码.
    register
        变量在CPU寄存器里面,而不是在内存里面.但register是建议型的指令,而不是命令型的指令

start 03-6整数类型与无符号数
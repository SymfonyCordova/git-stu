# c语言教程
## 环境搭建
    gcc -v
    g++ -v
    make -v
    gdb -v
    IDE QT http://download.qt.io/archive/qt/
    配置windows unix以达到都可以运行

## include头文件包含
    include是要告诉编译器，包含一个头文件，
    在Ｃ语言当中，任何库函数调用都需要提前包含头文件
    
    <头文件>,代表让c语言编译器去系统目录下寻找相关的头文件.
        在linux下会到/usr/include/目录下找
    “头文件”,代表让c语言编译器去用户当前目录下寻找相关头文件
    
    如果是使用了一个c语言库函数需要的头文件,那么一定是＃include <>   
    如果使用了一个自定义的.h文件,那么一定是#include “”
    如果你把你自定义的.h文件也放到系统目录的/usr/include目录下那么可以使用 <>

## main函数
    main函数是Ｃ语言中的主函数,一个Ｃ语言的程序必须有一个主函数，也只能有一个主函数

## 注释
    //代表注释，就是一个文字说明，没有实质的意义,单行注释	是c++语言的注释方法
    /**/,对行注释,对行注释是标准Ｃ语言注释方法

## {}括号，程序题和代码块
    c语言所有函数的代码都是{}里面包着的

## 声明
    int a
    声明一个变量名字叫a, 对于c语言，变量的名称是可以自定义

## c语言自定义名字的要求
    可以使用大小写字母，下划线，数字，但第一个字母必须是字母或者下划线，
    字母区分大小写
    不能用c语言的关键字作为变量名称
    每一行，必须是分号结尾

## printf 函数
    printf是向标准输出设备输出字符串的
    如果要输出一个字符串：例如:printf(“hello world” );
    如果要输出一个整数,例如: printf(“%d”, 整数)
    Printf(“\n”); 会输出一个回车换行符

## return 语句
    一个函数遇到return 语句就终止了,　return是c语言的关键字

## System系统调用
    system库函数的功能是执行操作系统的命令或者运行指定的程序
    system库函数的调用需要include <stdlib.h> 
        例子
            #include <stdio.h>
            #include <stdlib.h>
            int main(){
                printf("hello world\n");
                system("cat a.c");
                return 0;
            }
    system返回值在windows和unix下的不同
    
    POSIX标准
        b.c:
            #include <stdio.h>
            int main(){
                printf("hello world\n");
                return 100; //主函数return 0一般代表成功的意思,-1代表失败的意思
            }
        a.c:
            #include <stdio.h>
            #include <stdlib.h>
            int main(){
                printf("hello world\n");
                int i = system("cat a.c");
                int b = system("./b");
                printf("%d\n", i);
                printf("%d\n", b); //windows是100 linux是25600
                printf("%x\n", b); //windows是64 linux是6400
                printf("i = %x\n", b / 0x100); //64
                printf("i = %d\n", b / 0x100); //在linux修改以下这个就得到和windows一样的
                //所有的操作系统就windows是最特殊的
                //所以linux写一套代码很多代码都是通用的
                //为什么不一样呢?POSIX标准
                return 0;
            }
        是c语言的代码一种标准和规范
        如果不符合POSIX，代码的运行结果是不一样的
        windows支持的很差
        所以我们在使用库和函数的时候要使用p开头的,符合POSIX标准
        比如在多线程的时候我们最好使用pthread_create



## C语言编译过程,gcc参数简介
    gcc -o a a.c
        在windows编译后是a.exe
        在linux编译后是a，linux是文件名,带不带扩展无所谓的
        生成后的名字自定义的,linux如果不起名字,就是a.out
    
    c语言编译过程
        .c文件－＞预编译－＞编译－＞链接－＞可执行程序
        还有c的库加上去
    
    -E预编译	
        gcc -Ｅ -o a1.c a.c
        预编译a.c文件,生成的目标文件名为a.e
        预编译是将include包含的头文件内容替换到c文件中,同时将代码中没有的注释部分删除
        例如 #include <stdio.h>是将/usr/include/stdio.h文件内容替换到c的文件的中
    
    -S汇编
        gcc -S -o a.s a1.c
        -S就是将c语言转化为汇编语言
    
    -c编译(小写的c)
        gcc -c -o a.o a.s
        将代码编译为二进制的机器指令,但是不能执行
        
    连接(小写的o)
        gcc -o c c.o
        比如printf这个函数是c语言第三方库函数，linux叫.so windows叫.dll
        连接就是将这个函数的二进制连接到我们的程序中一起,然后才能运行
        也就是将库打包到我们的程序中
        gcc没有任何参数,代表就是链接
    
    可以看出java不是这个过程,java编译后不是可执行文件,是一个字节吗文件
    所以java是解释性语言
    
    gcc这个软件命令是很多的命令可以有很多的参数，以上是常用的
        gcc --help
        man gcc

## 操作系统结构
    计算机内存分用户区和内核区
    用户区:普通用户运行在用户区
    内核区:操作系统运行在内核区域
    32位操作系统,最大内存为4G，操作系统占用1G，剩下3G给用户程序
    32为操作系统即使你的硬件内存是8G但是它的最大内存是4G,只能使用4G，所以浪费
    64位操作系统,可能根硬件有关系不一定是2的64次方，但是最大内存肯定是大于4G的
    
    用户模式
        应用程序都是运行在用户区域
    内核模式
        操作系统的内核,设备驱动程序,这些都在内核模式下运行的


## 64位,32位系统的区别
    CPU内部结构与寄存器
        CPU里面有很多电气单元的,有运算器,控制器,寄存器
        例如寄存器有
            4位寄存器 
            8位寄存器  al bl
            16位寄存器 ax bx
            32位寄存器 eax ecx
            64位寄存器 reax rebx
        寄存器越大,那么能计算的数越大
        为了保证CPU的向下兼容性,
        32位CPU有 32位寄存器 16位寄存器 8位寄存器 4位寄存器 (最大寄存器是32位的)
        64位CPU有 64位寄存器 32位寄存器 16位寄存器 8位寄存器 4位寄存器 (最大寄存器是64位的)
    
        操作系统是c语言写完编译的
        所以32位操作系统是在32位CPU下编译的，是可以运行在64位CPU下的 但是发挥不出来64位CPU的计算能力
        但是64位操作系统是在64位CPU下编译的,是不可以运行在32位CPU下的，因为32位CPU没有64位的寄存器
    
        所以同样的c语言代码可能在32位操作系统与64位操作系统运行的结果可能不一样

## RISC与CISC CPU架构
    20%的指令位常用指令,在一个程序执行的时候会调用比例达到80%
    80%的指令位不常用指令,在一个程序执行的时候调用比例为20%
    
    RISC精简指令集 
        比如大部分的手机使用ARM体系指令集就是精简指令集
        把常用的指令放到CPU中 不常用的指令去除 不常有指令的功能用软件去实现
        例如把mp3的指令放到CPU中,就不需要写程序调mp3直接就可以使用指令来操作
    CISC复杂指令,一般来讲x86构架的cpu都是复杂指令集,AMD,intel就是x86构架的
        linux就是基于x86的操作系统
    SPARC, x86与ARM
        Sun有自己的CPU,就是基于SPARTC,其实就是一款RISI的CPU

## 汇编语言
    I386汇编简介
        mov eax, 10
        add eax, 10
        sub eax 20
        call printf
    VS反汇编
        先F9设置一个断点
        F5,用调试方法运行代码
    IDE工具
    QT常用快捷键
        Ctrl + /
    VS常用快捷键
        断点F9
    VS断点,调试

## 常量
    常量就是在程序中不可变化的量,常量在定义的时候必须给一个初始值
    #define 定义一个宏常量
    const 定义一个const常量
    
    字符串常量
        “hello world”
    对于#define类型的常量,c语言的习惯是常量名称为大写,
    但对于普通const常量以及变量,一般为小写结合大写的方式.
    
    例子
        #include <stdio.h>
        #define MAX 10 //定义一个宏常量，值为10
        int main(){
            printf("%d\n", 10);
            printf("%d\n", MAX);
            const int i = 100;
            printf("%d\n", i);
            return 0;
        }

## 二进制数, 位, 字节与字
    我们习惯于十进制的数: 10, 12等
    一个位只能表示0,或者1两种状态简称bit
    一个字节为8个二进制,称为８位,简称BYTE(8bit)
    一个字为２个字节,简称WORD(16bit)
    两个字为双字,简称DWORD(32bit)

## 八进制
    八进制以8为基数的数制系统,c语言当中0表示八进制,0666;

## 十六进制
    十六进制值16为基数的数值系统,c语言中用0x表示十六进制
    十进制	二进制	八进制	十六进制
    0	0	0	0
    1	1	1	1
    2	10	2	2
    3	11	3	3
    4	100	4	4
    5	101	5	5
    6	110	7	6
    7	111	7	7
    8	1000	10	8
    9	1001	11	9
    10	1010	12	a
    11	1011	13	b
    12	1100	14	c
    13	1101	15	d
    14	1110	16	e
    15	1111	17	f
    16	10000	20	10
    17	10001	21	11
    二进制与八进制和十六进制是一一对应的,二进制转八进制(按三位分组，单独计算,拼接)二进制转十六进制(按四位分组，单独计算,拼接)
    十进制转八进制,用十进制数作为被除数,8做为除数,取商数和余数,直到商数为0的时候,将余数倒过来就是转换的结果
    十进制转八进制,用十进制数作为被除数,16做为除数,取商数和余数,直到商数为0的时候,将余数倒过来就是转换的结果

## 原码
    将最高为数为符号位(0代表正, 1代表负),其余各位代表数值本身的绝对值
    +7的原码是  0000 0111
    -7的原码是   1000 0111
    +0的原码是  0000 0000
    -0的原码是　 1000 0000 

## 反码
    一个数如果为正,那么反码和原码相同
    一个数如果为负,那么符号为１,其他各位与原码相反
    +7的原码是  0000 0111
    -7的反码是　 1111 1000
    -0的反码是   1111 1111　

## 补码
    补码=反码+1 计算机数存的时候都是该数的补码

    原码和反码都不利于计算机的运算,如：原码表示的7和-7相加,还需要判断符号位.
    正数:原码,反码补码都相同
    负数:最高为１,其余各位原码取反,最后对整个数+1(也就是反码加1)
    补码符号位不动,其他为求反,最后整个数+1,得到原码
    
    用补码进行运算,减法可以通过加法来实现 
    ７-6=1
    7的补码和-6的补码相加: 0000 0111 + 1111 1010 = 1000 0001
    几位舍弃后,剩下的00000001 就是1的补码
    
    计算机数存的时候都是该数的补码
    内存的单位都是字节
    在32位操作系统和64位操作系统所有的类型都是不一样的
    
    无论是原码，反码，补码在转换的过程中最高位符号位不要动它
    无论是原码，反码，补码在转换的过程中先用sizeof判断当前类型是几个字节的在做转换

## sizeof 关键字
    sizeof 是c语言关键字,功能是求指定数据类型在内存中的大小,单位:字节
    一个整数在32位操作系统下,是4个字节，在嵌入式系统不一定
    一个整数在32位操作系统下,最大存储的数是2的32-1次方
    一个整数在64位操作系统下,最大存储的数是2的64-1次方
    为什么减1因为最高位是符号位
    
    size_t
    无论是原码，反码，补码在转换的过程中先用sizeof判断当前类型是几个字节的在做转换

## int类型
    int常量,变量
        int就是32位的一个二进制整数,在内存当中占据4个字节空间
    printf输出int值
        %d,　输出一个有符号的十进制整数
        %u, 代表输出一个无符号的十进制整数
    printf输出八进制和十六进制
        有一个概念是无论二进制，八进制和十六进制一定是固定写法,十进制才表达负数
        %x,代表输出十六进制数 
        ％Ｘ,用大写字母方式输出16进制数
        %o,代表输出八进制数
    short, long, long long, unsigned int
        short 意思为短整数,在32位操作系统下是２个字节，(16个比特)
        long意思为长整数,在32位操作系统下是４个字节，(３２个比特),在6４位系统下,windos还是４个字节，unix下称了8个字节,但这个也是不一定的
        int 不管是在32位系统下,还是64位系统下,无论是windows还是unix都是4个字节的
        long long 不管是在32位系统下,还是64位系统下,无论是windows还是unix都是8个字节的
        unsigned int 
        c语言所有的整数都可以加unsigned(无符号数的意思)
    
        一定要记住计算机存的是补码
        无论是原码，反码，补码在转换的过程中先用sizeof判断当前类型是几个字节的在做转换
        无符号数直接把这个数的补码当成正数输出了
            #include <stdio.h>
            int main(){
                printf("%d\n", 7);  //7
                printf("%u\n", -7); //4294967289
                return 0;
            }

## 整数溢出
    计算一个整数的时候超过整数能够容纳的最大单位后,整数会溢出,溢出的结果是高位舍弃，符号位丢失
    当一个小的整数赋值给大的整数,符号位不丢失,会继承

## 大端对齐与小端对齐
    内存都是以字节为单位的 8个bit
    int a = 0x12345678; 怎么看这句代码呢 4个bit可以把16进制的16个数字包括,所以a的每个数字占4个bit
        所以a放到内存中的时候是2个数字放在一个内存的字节里面 12 34 56 78
        
    对于arm，intel这种x86构架的复杂指令CPU,整数在内存中是倒者存放的,低地址放低位,高地址放高位,小端对齐.
        78    56  34  12
        低地址        高地址
    但对于unix服务器的CPU,更多是采用大端对齐的方式存放整数

## char类型
    char常量,变量 
        char c; 定义一个char变量
        ＇a＇,char的常量
        char的本质就是一个整数,一个字节大小的整数,相当于byte
    printf输出char
        ％c意思是输出一个字符,而不是一个整数
    不可打印char转义字符
        \a,报警
        \b,退格 退一格并且把前面的一个字符擦掉
        \n,换行 
        \r,回车 会退到这一行的最前段,并且把第一个字符擦掉
        \t,制表符
        \\,斜杠
        \’单引号
        \”双引号
        \?问好
    char和unsigned char
        char取值范围为-128到127
        unsigned char 为0-255

## 浮点float，double,long double类型
    浮点常量,变量
    float 在32位系统下是４个字节,double在32位系统下是8个字节
    小数的效率很低,避免使用,除非明确的要计算一个小数
    
    printf输出浮点数
        %f是输出一个double
        %lf输出一个long double
    
    如何对浮点数进行四舍五入？浮点数+0.5 然后直接按照整数一般的运算

## 类型限定
    const
        const 是代表一个不能改变值的常量
    volatile
        代表变量是一个可能被CPU指令之外的地方改变的,编译器就不会针对这个变量去优化目标代码.
    register
        变量在CPU寄存器里面,而不是在内存里面.但register是建议型的指令,而不是命令型的指令

## 字符串在计算器内部的存储方式
    字符串是内存中一段连续的char空间,以”\0”结尾
    “”是c语言表达字符串的方式

​	printf格式字符

| 字符 | 对应的数据类型     | 含义                                                         |
| :--- | :----------------- | :----------------------------------------------------------- |
| d    | int                | 接受整数数值并将它表示为有符号的十进制整数                   |
| hd   | short int          | 短整数                                                       |
| hu   | unsigned short int | 无符号短整数                                                 |
| o    | unsigned int       | 无符号的8进制整数                                            |
| u    | unsigned int       | 无符号的10进制整数                                           |
| x/X  | unsigned int       | 无符号的16进制整数,x对应的是abcdef,X对应的是ABCDEF           |
| f    | float或double      | 单精度浮点数或双精度浮点数                                   |
| e/E  | double             | 科学技术法表示数,此处e的大小写在输出时用e的大小写            |
| c    | char               | 字符型,可以把输入的数字按照ASCII码相应转换为对应的字符       |
| s/S  | char */wchar_t     | 字符串,输出字符串的字符直至字符串的空字符(字符串以’\0’结尾,这个＇\０＇即是空字符) |
| p    | void *             | 以16进制形式输出指针                                         |
| %    | %                  | 输出一个百分号                                               |

​	Printf　附加格式

| 字符            | 含义                                                      |
| --------------- | --------------------------------------------------------- |
| l               | 附加在d,u,x,o表示长整数                                   |
| －              | 左对齐                                                    |
| m(代表一个整数) | 数据最小宽度                                              |
| ０              | 将输出前面补上0,直接占满指定列宽为止（不可以搭配使用”-”） |
| N代表一个整数   | 宽度至少为n位,不够空格填充                                |

​	putchar是显示一个字符的函数

​	scanf函数与getchar函数
​		scaf通过键盘读取用户输入,放入变量中,记得参数一定是变量的地址(&)
​		getchar得到用户键盘输入的字符

## 运算符表达式和语句
    基本运算符
        =
            数据对象:泛指数据内存的存储区域
            左值:表示可以被更改的数据对象
            右值:能赋值给左值的量
        + - * / % += -= *= /= %= 
        ++自加1	
            i++先计算表达式的值,然后再++
            ++i是先++，再计算表达式的值
        --
        逗号运算符
            逗号表达式先求逗号左边的值,然后求右边的值,整个语句的值是右边的值
        	int a = 2;
            int b = 3;
            int c = 4;
            int d = 5;
            int i = (a = b, c + d);
​	运算符的优先级

| 优先级 | 运算符                                                       | 结合性   |
| ------ | ------------------------------------------------------------ | -------- |
| １     | ＋＋(后缀),--(后缀),()(调用函数),{}(语句块),.,->             | 从左到右 |
| ２     | ++(前缀),--(前缀),+(前缀),-(前缀),!(前缀),sizeof,*(取指针值),&(取地址),type(类型转化) | 从右到左 |
| ３     | *, /, %                                                      | 从左到右 |
| ４     | ＋，－                                                       | 从左到右 |
| ５     | << >>                                                        | 从左到右 |
| ６     | < > <= >=                                                    | 从左到右 |
| 7      | == !==                                                       | 从左到右 |
| 8      | ＆                                                           | 从左到右 |
| 9      | ＾                                                           | 从左到右 |
| 10     | ｜                                                           | 从左到右 |
| 11     | ＆＆                                                         | 从左到右 |
| 12     | ｜｜                                                         | 从左到右 |
| 13     | ？                                                           | 从右到左 |
| 14     | =, *=, %=, +=, -=, <<=,>>=,&=,\|=,^=                         | 从右到左 |
| 15     | ，(逗号运算符)                                               | 从左到右 |

复合语句

​	｛｝代码块

空语句

​	只有一个;号的语句就是空语句,空语句在c语句里面是合法的,并且是在某些场合必用的　例如: for死循环

类型转化

​	double f = (double)3 / 2　　()为强制类型转化运算符


## 条件分支语句
    关系运算符
        在c语言中0代表false,　非0代表真
        < <= > >= == !=
    关系运算符优先级
        前四种相同,后两种相同,前四种高于后两种优先级
    逻辑运算符
        && || ! if 
        if else
        if else if
        switch 与 break,default
    多重选择
        什么时候用if, 什么时候用switch
        当条件很复杂,一个条件中有&&, ||, !存在,那么用if语句
        如果条件很简单, 但分支很多,那么适合用switch	
    条件运算符?
        一个求绝对值的例子
            int i = -8;
            int x = ( i < 0) ? -i : i;
    goto语句和标号
        无条件跳转goto
        不建议使用goto语句,goto语句会使你的程序可读性很差

## 循环语句
    while
        while(条件),如果条件为真,循环继续,条件为假,循环结束
        while(1)是死循环
    continue
        循环遇到continue语句,不再执行continue下面的代码,而是直接返回循环起始语句处继续执行循环.
    break
        循环遇到break语句,立刻终端断开,循环结束
    do while
        do
            语句
        While(条件)
        对于do while来讲,循环的复合语句至少可以被执行一次
        对于while来讲,有可能复合语句一次执行机会都没有
    for
        for(;0;){}　一次都不会执行
        for(;1;){}　死循环
    循环嵌套

## 数组
    一维数组定义与使用
        int array[10];//定义了一个一维数组,名字叫array,一共有10个元素,每个元素都是int类型
    数组内存的存储方式
        数组在内存中就是一段连续的空间,每个元素的类型都是一样的
    一维数组初始化
        int array[10] = {1,2,3,4,5,6,7,8,9};
        int array[10] = {1,2,10};将数组前三个赋值为1,2,10,其余都为0
        int array[10] = { 0 };将数组的元素都置为0
    二维数组定义与使用
        int array[2][3];
    二维数组初始化
        int array[2][3] = { {1, 2, 3}, {4, 5, 6} };

## 字符串与字符数组
    字符数组定义
        char array[100];
    字符数组初始化
        char array[100] = { 'a','b','c','d' };
        char array[100] = "hello world";
        char array[100] = { 0 }; 空
        char array[] = "abcd"; //缺省用法　长度为5
    字符串一定是在内存中以0结尾的一个char数组
    
    字符数组使用
        Gbk 汉字占２个字节
        Utf8汉字占3个字节
        如果将一个字符串当做char处理,那么标准ASCII字符一定是一个正数,汉字的第一个字节一定是一个负数
    
    随机数产生函数rand和srand
        头文件 stdlib.h
        Rand是伪随机数产生器,每次调用rand产生的随机数是一样的
        如果调用rand之前先调用srand就出现任意的随机数
        只要能保证每次调用srand函数的时候,参数的值是不同的,那么rand函数就一定会产生不同的随机数
        
        #include <stdio.h>
        #include <stdlib.h>
        #include <time.h>
    
        int main()
        {
            timer_t tm = time(NULL);
            srand(tm);
            int i;
            for(i = 0; i < 10; ++i){
    
                int value = rand();
                printf("%d\n", value);
            }
            return 0;
        }
    用scanf输入字符串
        scanf(“%s”, s) //注意数组的长度
        scanf(“%d”, &a)
    字符串的结束标志
        scanf将回车,空格都认为是字符串输入结束标志
    字符串处理函数
        gets
            char s[100] = { 0 };	
            gets(s);//gets认为回车的输入结束标示,空格不是输入结束标示,所以用gets这个函数就可以实现输入带空格的字符串
            gets不能类似”%s”或者”%d”之类的字符转义,只能接受字符串的输入
        fgets函数
            gets函数不检查预留缓冲区是否能够容纳用户实际输入的数据.多出来的字符会导致内存溢出,fgets函数改进了这个问题
            由于fgets函数是为读取文件设计的,所以读取键盘时没有gets那么方便
            
            char s[100] = { 0 };
            fgets(s, sizeof(s), stdin);
        puts 函数
            puts函数打印字符串,与printf不同,puts会在最后自动添加一个”\n”
        fputs是puts的文件操作版本
            fputs是puts的文件操作版本
            char s[] = “hello world”;
            fputs(s, stdout);
        strlen,字符串长度
            size_t strlen(const char * _Str);
            返回不包含字符串结尾’\０’的字符长度
        strcat 字符串追加
            size_t strcat(char * _Str1, const char * _Str2)
            将参数_Str2追加到_Str1后尾
        strncat,字符串有限追加
            size_t strncat(char * _Str1, const char * _Str2, size_t)
        strcmp,字符串比较
            int strcmp(const char * _Str1, const char * _Str2);
            比较两个字符串是否相等,相等返回0,不等返回非0
        strncmp,字符串有限比较
            int strcmp(str1, str2, 5);
        strcpy 字符串拷贝
            char *strcpy(char * _Str1, const char * _Str2);
            将参数_str2拷贝到参数_str1
        strncpy 字符串有限拷贝
        sprintf
            和printf函数功能类似,printf函数将格式化结果输出到屏幕,sprintf将格式化结果输出字符串
        sscanf函数
            sscanf类似与scanf函数,scanf从键盘读取用户输入,scanf指定格式化字符串读取输入
        strchr查找字符
            char * strchr(char * _str , int _Ch);
            在参数_str中查找参数_ch指定字符,找到返回字符_ch在_str中所在的位置，没有位置返回null
        strstr查找子串
            char * strstr(char * _str, const char * _substr);
            在参数_str中查找参数_substr指定子串,找到返回子串在_str中所在的位置,没有找到返回null
        strtok分割字符串
            字符在第一次调用的时strtok()必须给予参数s字符串,往后的调用则将参数s设置成null每次调用成功则返回指向被分割出片段的指针
                char buf[] = "abc@defg@igk";
                char *p = strtok(buf, "@");
                while (p) {
                    printf("%s\n", p);
                    p = strtok(NULL, "@");
                }
        atoi 转换为int
            需要包含头文件stdlib.h
        atof 转换为float
        atol 转换为long
 04-01
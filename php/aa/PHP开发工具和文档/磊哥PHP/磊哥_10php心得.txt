数据库设计的三范式	
	第一范式(1NF)
		原子性
	第二范式(2NF)
		主键决定其他字段
		其他字段依赖主键
	第三范式(3NF)
	经验总结：
		通常，在设计表的时候，基本只要遵循这样的一个原则，就可以满足三范式
		每一种数据,使用一个表来存储
		
数据操作语言
	插入数据(增)：
		多种语法形式:
			形式1：insert[into] 表名 [(字段名1，字段名2，...)]values(值表达式1,值表达式2,...),(...),(...)
				这是最常用的插入语句，可以一次性插入多行数据,用逗号隔开,
				插入语句，要理解为每次插入数据都是以"行"为单位进行插入
				字段名通常不推荐省略,其后续的"值列表"应该跟字段名列表"一一对应"
				其中的值表达式，可以是一个"直接",或"函数调用结果",或变量值；其中,如果对应字段
				是字符或时间类型,则直接值应该使用单引号;
			形式2：replace[into] 表名 [(字段名1，字段名2，...)]values(值表达式1,值表达式2,...),(...),(...)
				跟insert into 几乎一样:唯一区别是,如果插入的数据的主键或唯一键"有重复值",则此时就会变成"修改行数据"
			形式3：insert[into] 表名 [(字段名1，字段名2，...)]select 字段名1,字段名2,...from其他表名;
				将select语句查询的结果数据(可能多条),都插入到指定的表中。
				其中,也需要注意字段的对应：select出来的字段列表,要跟前面指定的字段列表"一一对应"
			形式4：insert[into] 表名 set 字段名1=值表达式1,字段名2=值表达式2...
				
			load data 语法(载入语法)
				它适用于载入"结构整齐的纯文本数据"
				当然,前提是,有一个这样的对应结构的现有的表
create table tab_load_data(
id int auto_increment primary key,
name varchar(10),
sex enum('男','女'),
jiguan varchar(10),
f5 int 
);
		语法形式：load data infile "完整的数据文件路径" into table 表名
	删除数据(删)：
		语法形式：
			delete from 表名 [where 条件] [order by 排序] [limit 限定]
		说明：
			删除数据仍然是以"行"为单位进行。
			通常删除数据都需要where条件,否则就会删除所有数据(这很不常见)
			where条件的语法跟select中的语法一样
			order by 排序设定,用于这些数据的删除顺序;它通常跟limit配合使用才有意义
			limit 选定用于设定删除多少行(按order by 设定顺序)
	修改数据(改)：
		语法形式：
			update 表名 set 字段1=值1,字段2=值2,字段3=值3,[where 条件][order by 排序][limit 限定]
		说明：
			通常修改数据也需要where条件,否则就会删修改所有数据(这很少见)
			where条件的语法跟select中的语法一样
			order by 排序设定,用于这些数据的修改顺序;它通常跟limit配合使用才有意义
			limit 选定用于设定修改多少行(按order by 设定顺序)	
		注意:其中的数据值,如果是字符串或时间类型的"直接值",就应该用单引号;

基本查询
	select [all | distinct] 字段或表达式列表 [from 子句] [where 子句] [group by 子句] [having 子句] [order by 子句] [limit 子句]
		字段,自然是来源于"表"则其必然依赖于from子句
		表达式是类似这样一个内容：8，8+3，now() concat()函数是mysql中的系统函数,用于连接多个字符串
		每个输出项(字段或表达式结果),都可以给其设定一个别名(字段别名)形式为：字段或表达式 as 别名
		注意:实际上,表的字段并没有改变,而只是改变了"结果集"的字段名	
	all 和 distinet
	用于设定select 出来的数据,是否消除"重复行",可以不写,那就是默认值all
		all:表示不消除,即所有都出来,默认值
		distinct：表示会消除
	from 子句表示select部分从中"取得"数据的数据源--其实就是表
		通常,其后面就是表名；比如 from tab1
		但,也可能是其他一些数据源：比如 from tab1,tab2(连接表)
	where 子句
		说明：
			1、where子句就是对from子句中的"数据源"中的数据进行筛选的条件设定,筛选的机制是"一行一行进行判断"
			2、则,可见,where子句中依赖于from子句
			3、where子句中,通常都需要使用各种"运算符"
				算术运算符: + - * / %
				比较运算符:> >= < <= =(等于) <>(不等于) ==(等于) !=(不等于)
				逻辑运算符: and or not 
			4、对where子句的进一步理解
				where true 全部出来where false 不出来   where 1    where 0 
		
	is 运算符:空值和布尔值的判断
	有4种情况的使用:
		xx is null : 判断某个字段是'null'值就是没有值;
		xx is not null ：判断某个字段不＇ｎｕｌｌ＇值
		xx　is　true：判断某个字段为＂真＂(true)
		xx　is　false:判断某个字段为"假" (false)：0,0.0,'',null
	所谓 布尔值,其实是tinyint这个类型的一个别名，本质上,只是判断一个数字是否为0；

	between运算符:用于判断某个字段的数据值是否在某个给定的范围--适用于数字类型
	语法：
		xx between 值1 and 值2
	含义：
		xx字段的值的给定值1 和值2之间,其实相当于 xx>=值1 and xx<=值2

	in运算符:给定确定数据的范围判断（单列）
	语法：
	     XX in (值1，值2，值3，)
	含义：
	    表示字段XX的值为所列出的这些值中的一个，就算是满足了条件；这些值,通常是零散无规律的.
	like运算符:对字符串进行模糊查找
	语法：
	    xx like '要查找的内容'
	含义:
	    实现对字符串的某种特征信息的模糊查找。它其实依赖以下2个特殊的"符号"
	    % ：它代表"任何个数的任何字符";
	    _ ： 下杆,它代表"一个任何字符";

	    name like '%罗%' 表示name中"罗"这一个字的所有数据行
	    name like '罗%'  表示name中以"罗"开头的所有数据行
	    name like '%罗'  表示name中以"罗"结尾的所有数据行
	    name like '罗_'  表示name中以"罗"开头的并只有2个字符的所有数据行
	    name like '_罗'  表示name中以"罗"结尾的并只有2个字符的所有数据行
	 一个新问题：
		如果我要找某个字段中含"%"或(_)的行,怎么办?转义就OK
		\%  \_
		name like '%\%%'
	group by 子句：分组
	形式:
	     group by 字段1 [desc | asc] ，字段2[desc|asc]
	说明:
	    1.分组是对"前述"已经找出的数据(即where已经筛选过了)进行某种指定标准(依据)的分组.
	    2.同时,该分组结果,可以同时指定其"排序方式":desc（倒叙） asc （顺序）
	    3.通常,分组就是一个字段(依据),2个以上很少。.
	什么叫分组？
	    以某个字段进行分类存放
	    结果为：在select语句中的"输出"部分,只应该出现"组的信息"：
	    select 组信息1.组信息2,.....
	    count(*) 
	    最大值：max(字段名)
	    最小值：min(字段名)
	    平均值：avg(字段名)
	    总和值：sum(字段名)
	    以上为mysql的内部函数
	
	having 子句
	   一句话：having的作用跟where完全一样,但其只是对"分组的结果数据"进行筛选
	   即 where 对原始数据进行筛 having 对分组之后的数据进行筛选

	order by 子句
	   它用于将前面"取得"的数据以设定的标准(字段)来进行排序以输出结果
	   order by 子弹 [asc|desc] 字段2 [asc|desc]
	   说明:
		1、对前面的结果数据以指定的一个或多个字段排序
		2、排序可以谁定正序asc desc 
		3、多个字段的排序,都是在前面一个字段的基础上,如果还有"相等值",才继续以以后须字段排序
php面向对象
	类 描述一类事物的总称 （相当于一个设计图 ）
	对象 一个具体的"物体" （实现这个图）
	代码中 对象离不开类 先有类才有对象
	属性:就是原来的变量,只是现在隶属于一个类 叫属性
	方法:就是原来的函数,只是现在隶属于一个类 叫方法
	注意:属性和方法,已经不能自由的使用,而是都要通过这个类或这个对象去使用。
		使用属性,就是把它当做一个"变量"去使用就好了,只需要该形式：对象-> 属性名;
		使用方法,就是把它当做一个"函数"去使用就好了,只需要该形式：对象-> 方法名;
	一个类,定义了一些属性和方法,
	则：
		这个类所创建出来的对象,也就自然有了这些属性和方法
class MyDreamGirl{
	var $name;
	var $age;
	var $edu;
	function xiyifu(){
		echo "<br>{$this->age}岁的{$this->name}在勤快地洗衣服";
	}	
	function zuofan(){
		echo "<br>{$this->age}岁的{$this->name}在快乐地洗衣服";
	}
}

class C1{
	var $ps1=1
}
形式1：
	$o1=new C1();//通过一个类,去new出一个对象
形式2：
	$o2=new $o1();//通过一个对象,去new出一个对象--其实是new出来的就对象所属类的一个新对象。
形式3：
	$s1="C1";//只是一个字符串变量而已
	$o3=new $s1()//这就是所谓的"可变类"--无非就是类的名字是一个变量而已。
形式4:
	$o4=new self()//self表示当前类本身,它只能出现在一个类的方法中。

对象的传值方式
对象值传递
	实际上,在变量$o1中,存储的数据只是一个"对象编号#1",这个对象编号,才会去指向对象数据
	new C1();该编号数据,我们不能控制,只是系统内部的分配。
	则$o2=$o1;作为值传递,实际复制的是该对象的编号
	在语法上,对对象变量进行的属性进行操作,其实就是通过该编号来指向对象而操作的.
	$o1->p1=2,//此时,就是通过对象编号#1去修改对象new C1() 本身的内不数据。
对象引用传递
	
类中成员
面向对象编程，是需要通过对象去做什么事情（以完成某种任务）;
而：
对象总是来源于类；
所以：
面向对象的编程,一切都是定义类开始;
类中成员分为3大类：
	属性：
	方法：
	常量：
形式上,大致如下：
class 类名{
	常量定义1;
	常量定义2;
	......
	属性定义1;
	属性定义2;
	......
	方法定义1;
	方法定义2;
	......
}
以上各项,没有顺序问题;习惯上,其实常量放在前面,然后是属性,然后是方法;
详细一点,就分为：
	属性：
		普通属性(实例属性)
			实例的单词为:instance
			实例,其实也叫做对象	
			普通(实例)属性,就是一个可以在该类实例化出的对象上使用的属性!
			定义形式:
				class 类名{
					var $属性名=初始值;
					var $属性名;//没有初始值
					//上述的var 还可以使用public来代替
					public $属性名=初始值;
					public $属性名;//没有初始值					
				}
			使用形式:
				是通过该类的对象,来使用普通属性(实例属性):
					$对象->属性名;
				因为,属性的本质就是变量,则其就可以当做一个变量来看待和使用,比如：
				$v1=$对象->属性名;
		静态属性
			本质上也是变量,但是有一个特点就是:该变量只隶属于类,即：
			一个类的一个静态属性,就只有"一份数据";
			但:
			一个类的一个实例属性,就可以有"多份数据"--每创建一个对象出来,就会有一份数据;
			定义形式:
				class 类名{
					static [public] $属性名 = 初始值;
					static [public] $属性名;//这个属性没有初始值;
				}
			使用形式:
				使用类名和范围解析符(::)来对静态属性进行操作:
					类名：：$静态属性名;
				对比1：
					常量的使用: 类名::常量名;
				对比2:
					实例属性的使用:对象名->实例属性名
			1、实例属性：是每个对象都可以不一样的数据,也是每个对象都"独自拥有的"数据;
			2、静态属性,他不属于任何一个对象,而只是该类本身,也可以理解为所有对象共有的。
	方法：
		普通方法
			一个类中定义的方法,可以为这个类的所有对象调用的方法,也可以理解为,这个类的所有对象,都各自有自己的一个方法;
			定义形式
				class 类名{
					function 方法名(形参1,形参2...){
						//方法体
					}
				}
			调用形式:
				$对象名->方法名(实参1,实参2,...);
		静态方法 
			一个类中定义的方法,只属于这个类本身,而不是隶属于这个类的对象。
			定义形式
				class 类名{
					static function 方法名(形参1,形参2...){
						//方法体
					}
				}
			调用形式:
				类名：：方法名(实参1,实参2,...);
				//self 表示代表当前所在的类 ,this 代表一个对象
		实例方法中可以使用静态属性
		静态方法中不能使用实例属性,只能使用静态属性
		构造方法
			1、名字是固定的:__construct;
			2、该方法通常都不要我们自己调用,而是在new一个对象的时候会自动调用
			3、该方法主要目的是为了在new一个对象的时候,给该对象设置一些初始值(初始化工作)
			4、构造方法的参数没有规定,通常是根据实际需求来定义,目的是为了对象属性数据的初始化
		析构方法
			1、析构方法是一个特殊的方法,名字为固定的词:__destruct
			2、析构方法是在一个对象被"销毁"的时候会自动被调用的方法--我们无法调用它,
			3、析构方法不能带参数(形参),但方法中也可以使用this这个词,代表"当前对象",
			//程序运行结束,变量(对象)肯定就会被销毁
	常量：
		class C1{
			const PI=3.14;//只有这一种方式 类常量
		}
		$v1=C1::PI;//用双冒号来使用
		//双引号不能识别常量
		
对象在哪些情况下会被销毁
1、如果程序结束,所有变量都会被销毁,自然变量所代表的对象也会被销毁;
对象的销毁的顺序,默认情况下,跟其创建的顺序相反
2、当一个对象没有任何变量"指向"它的时候,即使程序还没有结束,也会被销毁;
unset(对象)
对象被引用的变量被赋值了也就不在是对象编号了就不能使用对象此时也销毁了;
